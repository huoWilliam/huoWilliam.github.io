<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo折腾记（1）——安装与使用NexT主题</title>
    <url>/2020/06/30/Hexo%E6%8A%98%E8%85%BE%E8%AE%B0%EF%BC%881%EF%BC%89%E2%80%94%E2%80%94%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8NexT%E4%B8%BB%E9%A2%98/</url>
    <content><![CDATA[<h1 id="安装NexT"><a href="#安装NexT" class="headerlink" title="安装NexT"></a>安装NexT</h1><p>Next的安装分为三步骤：</p>
<ol>
<li><p>下载主题</p>
<p>进入Hexo站点目录下，使用<code>git clone</code>下载最新的NexT主题。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$cd</span> your-hexo-site</span><br><span class="line"><span class="variable">$git</span> <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>

<div class="note info"><p>当要更新NexT主题的时候，可以进入theme/next文件夹下，使用<code>git pull</code>，进行更新合并 </p>
</div>
</li>
<li><p>启用主题</p>
<p>打开<strong>站点配置文件_config.yml</strong>，找到theme字段，并将其值改为<code>next</code>。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>验证主题是否正确启用</p>
<p>启动Hexo本地服务器，并开启调试模式，当出现如下命令提示时，说明启动成功：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">INFO  Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure>

<p>此时，可以用浏览器访问<code>http://localhost:4000</code>，检查Next是否配置成功，当出现如下画面时，说明NexT成功启用。</p>
<p><img src="https://theme-next.iissnan.com/uploads/five-minutes-setup/validation-default-scheme-mac.png" alt="NexT成功启用"></p>
</li>
</ol>
<h1 id="外观切换"><a href="#外观切换" class="headerlink" title="外观切换"></a>外观切换</h1><p>NexT提供了4种不同的外观进行切换，分别为Muse，Mist，Pisces，Gemini。</p>
<p>首先进入<strong>主题配置文件_config.yml</strong>，搜索scheme关键字。按个人喜好选择合适的外观。如下所示，设置外观为Pisces。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Scheme Settings</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Schemes</span></span><br><span class="line"><span class="comment">#scheme: Muse</span></span><br><span class="line"><span class="comment">#scheme: Mist</span></span><br><span class="line"><span class="attr">scheme:</span> <span class="string">Pisces</span></span><br><span class="line"><span class="comment">#scheme: Gemini</span></span><br></pre></td></tr></table></figure>

<h1 id="设置菜单"><a href="#设置菜单" class="headerlink" title="设置菜单"></a>设置菜单</h1><p>NexT默认只启用了home和archives两个菜单项。我们可以手动开启更多的菜单项。</p>
<ol>
<li><p>首先，进入<strong>主题配置文件_config.yml</strong>，搜寻menu关键字。按需要进行菜单设置，将需要使用的菜单项取消注释。如下所示，分别启用了菜单项：home，about，tags，categories，archives。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Menu Settings</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/||</span> <span class="string">home</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">/about/||</span> <span class="string">user</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/||</span> <span class="string">tags</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/||</span> <span class="string">th</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/||</span> <span class="string">archive</span></span><br><span class="line">  <span class="comment">#schedule: /schedule/ || calendar</span></span><br><span class="line">  <span class="comment">#sitemap: /sitemap.xml || sitemap</span></span><br><span class="line">  <span class="comment">#commonweal: /404/ || heartbeat</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>菜单项开启后，点击菜单项无法进入到对应的页面，我们需要为菜单项建立对应的页面。</p>
<ul>
<li><p>建立tags页面</p>
<p>首先，进入Hexo站点目录，新建一个页面，命名为tags：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$cd</span> your-hexo-site</span><br><span class="line"><span class="variable">$hexo</span> new page tags</span><br></pre></td></tr></table></figure>

<p>其次，编辑新建的页面，将页面类型设置为tags，主题将为该页面显示标签云。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">date: 2020-06-30 11:17:38</span><br><span class="line">type: "tags"</span><br><span class="line">comments: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
</li>
<li><p>建立categories页面</p>
<p>首先，进入Hexo站点目录，新建一个页面，命名为categories：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$cd</span> your-hexo-site</span><br><span class="line"><span class="variable">$hexo</span> new page categories</span><br></pre></td></tr></table></figure>

<p>其次，编辑新建的页面，将页面类型设置为tags，主题将为该页面显示标签云。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">date: 2020-06-30 11:17:38</span><br><span class="line">type: "categories"</span><br><span class="line">comments: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
</li>
<li><p>建立about页面</p>
<p>about页面的建立方法同时，不过<code>type: &quot;about&quot;</code>。</p>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo折腾记（2）——NexT设置背景图片</title>
    <url>/2020/06/30/Hexo%E6%8A%98%E8%85%BE%E8%AE%B0%EF%BC%882%EF%BC%89%E2%80%94%E2%80%94NexT%E8%AE%BE%E7%BD%AE%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<h1 id="设置背景图片（NexT-5-x）"><a href="#设置背景图片（NexT-5-x）" class="headerlink" title="设置背景图片（NexT 5.x）"></a>设置背景图片（NexT 5.x）</h1><p>NexT主题本身是没有背景图片的，设置一个个性化的背景图片，会让blog变得更加美观。</p>
<p>可以通过以下的方式为NexT主题设置背景图片。</p>
<ol>
<li><p>将想要的背景图片放入<code>themes/next/source/images</code>。</p>
</li>
<li><p>打开<code>themes/next/source/css/ _custom/custom.styl</code>文件，该文件是NexT提供给用户进行个性化定制的文件。在该文件中添加如下代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">//background设置</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>:<span class="built_in">url</span>(/images/EtretatSunrise.jpg);</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">	background-repeat: no-repeat;  //不重复</span><br><span class="line">	background-attachment: fixed; //固定</span><br><span class="line">	background-size: 100% 100%;   //图片大小随浏览器变化</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>background:url</code> 为图片路径，也可以直接使用链接。</li>
<li><code>background-repeat</code>：若果背景图片不能全屏，那么是否平铺显示，充满屏幕</li>
<li><code>background-attachment</code>：背景是否随着网页上下滚动而滚动，fixed 为固定</li>
<li><code>background-size</code>：图片展示大小，这里设置 100%，100% 的意义为：如果背景图片不能全屏，那么是否通过拉伸的方式将背景强制拉伸至全屏显示。</li>
</ul>
</li>
<li><p>设置背景后，可以考虑将博客文件降低透明度，这样可以更好地表现背景图片。</p>
<p>在<code>themes/next/source/css/_custom/custom.styl</code> 中添加以下内容：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">//博客内容透明化</span><br><span class="line">//文章内容的透明度设置</span><br><span class="line"><span class="selector-class">.content-wrap</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.9</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//侧边框的透明度设置</span><br><span class="line"><span class="selector-class">.sidebar</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.9</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//菜单栏的透明度设置</span><br><span class="line"><span class="selector-class">.header-inner</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,<span class="number">0.9</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//搜索框（local-search）的透明度设置</span><br><span class="line"><span class="selector-class">.popup</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.9</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="设置背景图片（NexT-7-x）"><a href="#设置背景图片（NexT-7-x）" class="headerlink" title="设置背景图片（NexT 7.x）"></a>设置背景图片（NexT 7.x）</h1><p>在NexT 7.x下设置背景图片的方式已经发生了变化。具体的设置方法如下：</p>
<ol>
<li><p>编辑<mark class="label primary">主题配置文件_config.yml</mark>，找到<code>custom_file_path</code>配置项目，取消该项目下的<strong>style</strong>前的注释。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">custom_file_path:</span></span><br><span class="line">  <span class="comment">#head: source/_data/head.njk</span></span><br><span class="line">  <span class="comment">#header: source/_data/header.njk</span></span><br><span class="line">  <span class="comment">#sidebar: source/_data/sidebar.njk</span></span><br><span class="line">  <span class="comment">#postMeta: source/_data/post-meta.njk</span></span><br><span class="line">  <span class="comment">#postBodyEnd: source/_data/post-body-end.njk</span></span><br><span class="line">  <span class="comment">#footer: source/_data/footer.njk</span></span><br><span class="line">  <span class="comment">#bodyEnd: source/_data/body-end.njk</span></span><br><span class="line">  <span class="comment">#variable: source/_data/variables.styl</span></span><br><span class="line">  <span class="comment">#mixin: source/_data/mixins.styl</span></span><br><span class="line">  <span class="attr">style:</span> <span class="string">source/_data/styles.styl</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在<strong>博客根目录下</strong>创建文件<mark class="label primary">your_blog/source/_data/styles.styl</mark>，然后在该文件中添加自定义配置。具体配置如下所示：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">//背景图</span><br><span class="line"><span class="selector-tag">body</span> &#123; </span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(/images/MarleyBeach.jpg);</span><br><span class="line">    background-attachment: fixed; // 不随屏幕滚动而滚动fixed,scroll,inherit</span><br><span class="line">    background-repeat: no-repeat; // 如果背景图不够屏幕大小则重复铺，no-repeat则表示不重复</span><br><span class="line">    background-size: cover; // contain等比例铺满屏幕 //cover拉伸铺满</span><br><span class="line">    background-position: bottom;//x,y轴调整</span><br><span class="line">    +<span class="selector-tag">mobile</span>()&#123;</span><br><span class="line">      //background-position: 0% -20%;https://i.loli.net/2018/12/29/5c270a0523154.jpg</span><br><span class="line">      //https://i.loli.net/2018/12/29/5c270fc2bfcad.png</span><br><span class="line">      background-image: url(/images/MarleyBeach.jpg);</span><br><span class="line">      <span class="selector-tag">background-size</span>: <span class="selector-tag">cover</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 修改文章块透明度</span><br><span class="line"><span class="selector-class">.post-block</span> &#123;</span><br><span class="line">	<span class="attribute">padding</span>: $content-desktop-padding;</span><br><span class="line">	background: rgba(255,255,255,0.9);   //white;</span><br><span class="line">	box-shadow: $box-shadow-inner;</span><br><span class="line">	border-radius: $border-radius-inner;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Comments blocks.</span><br><span class="line"><span class="selector-class">.comments</span> &#123;</span><br><span class="line">	<span class="attribute">padding</span>: $content-desktop-padding;</span><br><span class="line">	<span class="attribute">margin</span>: initial;</span><br><span class="line">	<span class="attribute">margin-top</span>: sboffset;</span><br><span class="line">	background: rgba(255,255,255,0.9);   //white;</span><br><span class="line">	box-shadow: $box-shadow;</span><br><span class="line">	border-radius: $border-radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 修改菜单栏透明度</span><br><span class="line"><span class="selector-class">.header-inner</span> &#123;</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">0.8</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.sidebar-inner</span> &#123;</span><br><span class="line">   	<span class="attribute">opacity</span>: <span class="number">0.9</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

 <div class="note info"><p>以后想自定义博客外观的话，都可以在该文件中进行修改，而不需要改动其他的文件</p>
</div></li>
</ol>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo折腾记（4）——添加脚注的方法</title>
    <url>/2020/07/02/Hexo%E6%8A%98%E8%85%BE%E8%AE%B0%EF%BC%884%EF%BC%89%E2%80%94%E2%80%94%E6%B7%BB%E5%8A%A0%E8%84%9A%E6%B3%A8%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="添加脚注"><a href="#添加脚注" class="headerlink" title="添加脚注"></a>添加脚注</h1><p>Typora的扩展语法支持脚注。但是，Hexo并不支持脚注，因此想要在Hexo上为文章内容添加脚注，必须借助于hexo-footnotes这款插件的帮助。安装该插件与使用的方法如下：</p>
<h2 id="安装hexo-footnotes"><a href="#安装hexo-footnotes" class="headerlink" title="安装hexo-footnotes"></a>安装hexo-footnotes</h2><p>进入站点根目录，使用Git，输入如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-footnotes --save</span><br></pre></td></tr></table></figure>

<p>如果，你的hexo可以自动检测所有的插件，则不需要修改<mark class="label info"> 站点配置文件_config.yml</mark>。</p>
<p>如果，不能自动检测插件的话，那么需要在<mark class="label primary"> 站点配置文件_config.yml</mark>中添加如下代码</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="attr">plugins:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo-footnotes</span></span><br></pre></td></tr></table></figure>

<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>该插件的语法与Typora的脚注语法相同，具体案例如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">basic footnote<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></span><br><span class="line">here is an inline footnote[<span class="string">^2</span>](<span class="link">inline footnote</span>)</span><br><span class="line">and another one<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup></span><br><span class="line">and another one<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup></span><br><span class="line"></span><br><span class="line">[<span class="symbol">^1</span>]: <span class="link">basic footnote content</span></span><br><span class="line">[<span class="symbol">^3</span>]: <span class="link">paragraph</span></span><br><span class="line">footnote</span><br><span class="line">content</span><br><span class="line">[<span class="string">^4</span>]: footnote content with some [<span class="string">markdown</span>](<span class="link">https://en.wikipedia.org/wiki/Markdown</span>)</span><br></pre></td></tr></table></figure>

<div class="note info"><p>注脚的内容最好放在文章的末尾，否则可能出错 。</p>
</div> 
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo折腾记（5）——设置加密访问</title>
    <url>/2020/07/02/Hexo%E6%8A%98%E8%85%BE%E8%AE%B0%EF%BC%885%EF%BC%89%E2%80%94%E2%80%94%E8%AE%BE%E7%BD%AE%E5%8A%A0%E5%AF%86%E8%AE%BF%E9%97%AE/</url>
    <content><![CDATA[<h1 id="设置加密访问"><a href="#设置加密访问" class="headerlink" title="设置加密访问"></a>设置加密访问</h1><p>设置加密访问可以通过hexo-blog-encrypt这个插件来实现，具体的设置与使用方法如下。</p>
<ol>
<li><p>安装插件</p>
<p>设置加密访问必须先安装hexo-blog-encrypt这个插件。进入站点根目录，启动Git，运行如下代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-blog-encrypt</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<mark class="label primary"> 站点配置文件_config.yml</mark>中启用该插件。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#encrypt</span></span><br><span class="line"><span class="attr">encrypt:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">default_message:</span> <span class="string">输入密码，查看文章。</span></span><br><span class="line">    <span class="attr">wrong_pass_message:</span> <span class="string">抱歉,</span> <span class="string">这个密码看着不太对,</span> <span class="string">请再试试.</span></span><br></pre></td></tr></table></figure>

<ul>
<li>default_message：设置默认提示信息</li>
<li>wrong_pass_message：设置密码输入错误提示信息</li>
</ul>
</li>
<li><p>在文章头部添加对应的字段，如password，abstrat等。就可以在blog中开启加密访问了。具体案例如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 文章加密</span><br><span class="line">date: 2019-01-04T22:20:13.000Z</span><br><span class="line">category: 教程</span><br><span class="line">tags:</span><br><span class="line"><span class="bullet">  - </span>博客</span><br><span class="line"><span class="bullet">  - </span>Hexo</span><br><span class="line">keywords: 博客文章密码</span><br><span class="line">password: TloveY</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>该插件也可以<strong>根据标签进行加密访问设置</strong>。设置方法是在<mark class="label primary"> 站点配置文件_config.yml</mark>中进行如下修改：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Security</span></span><br><span class="line"><span class="attr">encrypt:</span> <span class="comment"># hexo-blog-encrypt</span></span><br><span class="line">  <span class="attr">abstract:</span> <span class="string">有东西被加密了,</span> <span class="string">请输入密码查看.</span></span><br><span class="line">  <span class="attr">message:</span> <span class="string">您好,</span> <span class="string">这里需要密码.</span></span><br><span class="line">  <span class="attr">tags:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&#123;name:</span> <span class="string">tagName,</span> <span class="attr">password:</span> <span class="string">密码A&#125;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&#123;name:</span> <span class="string">tagName,</span> <span class="attr">password:</span> <span class="string">密码B&#125;</span></span><br><span class="line">  <span class="attr">wrong_pass_message:</span> <span class="string">抱歉,</span> <span class="string">这个密码看着不太对,</span> <span class="string">请再试试.</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo折腾记（3）——修改文章底部标签与设置头像</title>
    <url>/2020/06/30/Hexo%E6%8A%98%E8%85%BE%E8%AE%B0%EF%BC%883%EF%BC%89%E2%80%94%E2%80%94%E4%BF%AE%E6%94%B9%E6%96%87%E7%AB%A0%E5%BA%95%E9%83%A8%E6%A0%87%E7%AD%BE%E4%B8%8E%E8%AE%BE%E7%BD%AE%E5%A4%B4%E5%83%8F/</url>
    <content><![CDATA[<h1 id="修改文章底部标签"><a href="#修改文章底部标签" class="headerlink" title="修改文章底部标签"></a>修改文章底部标签</h1><p>将文章底部标签前的#，改为Font Awesome图标的方法，如下所述：</p>
<ol>
<li><del>打开文件<code>/themes/next/layout/_macro/post.swig</code>,搜索关键字<mark class="label primary">rel=tag>#</mark></del></li>
<li><del>将关键字中的<strong>#</strong>替换为<code>&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;</code></del></li>
</ol>
<p>对于NexT 7.x的设置方法已经发生了变化，具体的设置方法如下：</p>
<ol>
<li><p>打开文件<code>/themes/next/layout/_macro/post.njk</code>。</p>
</li>
<li><p>修改代码如下所示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;%- set tag_indicate &#x3D; &#39;&lt;i class&#x3D;&quot;fa fa-tag&quot;&gt;&lt;&#x2F;i&gt;&#39; if theme.tag_icon else &#39;&lt;i class&#x3D;&quot;fa fa-tag&quot;&gt;&lt;&#x2F;i&gt;&#39; %&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>显示效果如下图所示：</p>
<p><img src="/images/image-20200701000751413.png" alt="Hexo底部标签样式"></p>
<h1 id="设置头像"><a href="#设置头像" class="headerlink" title="设置头像"></a>设置头像</h1><ol>
<li><p>打开侧边栏头像显示</p>
<p>编辑<mark class="label primary">主题配置文件_config.yml</mark>，搜寻关键字avatar，将它的值设置成头像的连接地址。头像的链接地址可以是：</p>
<table>
<thead>
<tr>
<th align="left">地址</th>
<th align="left">值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">完整的互联网 URI</td>
<td align="left"><code>http://example.com/avatar.png</code></td>
</tr>
<tr>
<td align="left">站点内的地址</td>
<td align="left">将头像放置主题目录下的 <code>source/uploads/</code> （新建 uploads 目录若不存在） 配置为：<code>avatar: /uploads/avatar.png</code>或者 放置在 <code>source/images/</code> 目录下 配置为：<code>avatar: /images/avatar.png</code></td>
</tr>
</tbody></table>
</li>
<li><p>设置头像为圆形显示，并且鼠标放置上去后可旋转(optional)</p>
<p>默认的头像是以方形为边框，通过以下方法，可以将头像的边框设置为圆形的。</p>
<ul>
<li><p>打开文件<code>/themes/next/source/css/_commom/components/sidebar/sidebar-author.styl</code></p>
</li>
<li><p>修改<mark class="label primary">.site-author-image</mark>的设置，如下所示</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.site-author-image</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">  <span class="attribute">padding</span>: $site-author-image-padding;</span><br><span class="line">  <span class="attribute">max-width</span>: $site-author-image-width;</span><br><span class="line">  <span class="attribute">height</span>: $site-author-image-height;</span><br><span class="line">  <span class="attribute">border</span>: $site-author-image-border-width solid $site-author-image-border-color;</span><br><span class="line">  <span class="comment">/*start*/</span></span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">60%</span></span><br><span class="line">  transition: <span class="number">2s</span> all;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.site-author-image</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">360deg</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*end*/</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<div class="note info"><p>在NexT 7.x.x版本后，已经不需要进行上述复杂的操作，只需在主题配置文件中的avatar元素内，将rounded与rotated的值设置为true即可。</p>
</div>

<p>效果如下所示：</p>
<p><img src="/images/avata_rotate.webp" alt="头像旋转"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>【我不是药神】生来平凡，诚勇无惧</title>
    <url>/2020/07/08/%E3%80%90%E6%88%91%E4%B8%8D%E6%98%AF%E8%8D%AF%E7%A5%9E%E3%80%91%E7%94%9F%E6%9D%A5%E5%B9%B3%E5%87%A1%EF%BC%8C%E8%AF%9A%E5%8B%87%E6%97%A0%E6%83%A7/</url>
    <content><![CDATA[<iframe width="560" height="315" src="https://www.youtube.com/embed/ZiuqVjRzhuI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

<p>那药假不假<br>        我们能不知道吗<br>        那药才卖五百块钱一瓶<br>        药贩子根本没赚钱<br>        谁家能不遇上个病人<br>        你就能保证你这一辈子不生病吗<br>        你们把他抓走了<br>        我们都得等死<br>        我不想死<br>        我想活着<br>        行吗</p>
]]></content>
      <categories>
        <category>光影岁月</category>
      </categories>
      <tags>
        <tag>music</tag>
        <tag>movie</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/06/11/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<a id="more"></a>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      <categories>
        <category>test</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title>【我的团长我的团】岂曰无衣，与子同袍</title>
    <url>/2020/07/08/%E3%80%90%E6%88%91%E7%9A%84%E5%9B%A2%E9%95%BF%E6%88%91%E7%9A%84%E5%9B%A2%E3%80%91%E5%B2%82%E6%9B%B0%E6%97%A0%E8%A1%A3%EF%BC%8C%E4%B8%8E%E5%AD%90%E5%90%8C%E8%A2%8D/</url>
    <content><![CDATA[<iframe width="560" height="315" src="https://www.youtube.com/embed/3V16FAtsS24" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

<p>炮弹打不下春苗般的生机<br>铁翼下的种子徒生些抗力<br>应声站起来大时代的战士<br>高塔般竖立在我们的土地<br>什么力也瞬灭不了火炭般的眼睛<br>什么声也遮蔽不住愤怒的吼声<br>烟火里孕育着复兴的幼芽<br>真的，生存要从死里来争取<br>鲜血培养起自由之花<br>我们要在暗夜竖立火炬</p>
]]></content>
      <categories>
        <category>光影岁月</category>
      </categories>
      <tags>
        <tag>music</tag>
        <tag>movie</tag>
      </tags>
  </entry>
  <entry>
    <title>【霸王别姬】不疯魔，不成活</title>
    <url>/2020/07/08/%E3%80%90%E9%9C%B8%E7%8E%8B%E5%88%AB%E5%A7%AC%E3%80%91%E4%B8%8D%E7%96%AF%E9%AD%94%EF%BC%8C%E4%B8%8D%E6%88%90%E6%B4%BB/</url>
    <content><![CDATA[<iframe width="560" height="315" src="https://www.youtube.com/embed/SFVQgqVqeaw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

<p>一笑万古春，一啼万古愁。此境非你莫属，此貌非你莫有。</p>
]]></content>
      <categories>
        <category>光影岁月</category>
      </categories>
      <tags>
        <tag>music</tag>
      </tags>
  </entry>
  <entry>
    <title>一文看懂深度学习</title>
    <url>/2020/07/10/%E4%B8%80%E6%96%87%E7%9C%8B%E6%87%82%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p><img src="https://miro.medium.com/max/1050/0*MCioiwbkOjtFBLU8.png" alt="image for post"></p>
<blockquote>
<p><em>深度学习有很好的表现，引领了第三次人工智能的浪潮。目前大部分表现优异的应用都用到了深度学习，大红大紫的 AlphaGo 就使用到了深度学习。</em></p>
<p><em>本文将详细的给大家介绍深度学习的基本概念、优缺点和主流的几种算法。</em></p>
</blockquote>
<h1 id="深度学习、神经网络、机器学习、人工智能的关系"><a href="#深度学习、神经网络、机器学习、人工智能的关系" class="headerlink" title="深度学习、神经网络、机器学习、人工智能的关系"></a>深度学习、神经网络、机器学习、人工智能的关系</h1><p><strong>深度学习、机器学习、人工智能</strong></p>
<p>简单来说：</p>
<ol>
<li>深度学习是机器学习的一个分支(最重要的分支)</li>
<li>机器学习是人工智能的一个分支</li>
</ol>
<p><img src="https://miro.medium.com/max/2250/0*0m26vYcHghsHL-Bw.jpg" alt="Image for post"></p>
<p>目前表现最好的一些应用大部分都是深度学习，正是因为深度学习的突出表现，引发了人工智能的第三次浪潮。详情可以看《<a href="https://easyai.tech/blog/ai-history/" target="_blank" rel="noopener">人工智能的发展史 — — 3次 AI 浪潮</a>》</p>
<p><strong>深度学习、神经网络</strong></p>
<p>深度学习的概念源于人工神经网络的研究，但是并不完全等于传统神经网络。</p>
<p>不过在叫法上，很多深度学习算法中都会包含”神经网络”这个词，比如：卷积神经网络、循环神经网络。</p>
<p><strong>所以，深度学习可以说是在传统神经网络基础上的升级，约等于神经网络。</strong></p>
<p><img src="https://miro.medium.com/max/2250/0*jHGzSx46XNqse7k3.png" alt="Image for post"></p>
<h1 id="大白话解释深度学习"><a href="#大白话解释深度学习" class="headerlink" title="大白话解释深度学习"></a>大白话解释深度学习</h1><p>看了很多版本的解释，发现李开复在《<a href="https://amazon.cn/gp/product/B06Y4141WL/ref=as_li_qf_asin_il_tl?ie=UTF8&tag=106366349-23&creative=3200&linkCode=as2&creativeASIN=B06Y4141WL&linkId=de21a3460960208b0e4dd9cf5b99306c" target="_blank" rel="noopener">人工智能</a>》一书中讲的是最容易理解的，所以下面直接引用他的解释：</p>
<p>我们以识别图片中的汉字为例。</p>
<p>假设深度学习要处理的信息是“水流”，而处理数据的深度学习网络是一个由管道和阀门组成的巨大水管网络。网络的入口是若干管道开口，网络的出口也是若干管道开口。这个水管网络有许多层，每一层由许多个可以控制水流流向与流量的调节阀。根据不同任务的需要，水管网络的层数、每层的调节阀数量可以有不同的变化组合。对复杂任务来说，调节阀的总数可以成千上万甚至更多。水管网络中，每一层的每个调节阀都通过水管与下一层的所有调节阀连接起来，组成一个从前到后，逐层完全连通的水流系统。</p>
<p><img src="https://miro.medium.com/max/2250/0*9i7eqIi0v_rZ69i8.png" alt="Image for post"></p>
<p>那么，计算机该如何使用这个庞大的水管网络来学习识字呢？</p>
<p>比如，当计算机看到一张写有“田”字的图片，就简单将组成这张图片的所有数字（在计算机里，图片的每个颜色点都是用“0”和“1”组成的数字来表示的）全都变成信息的水流，从入口灌进水管网络。</p>
<p><img src="https://miro.medium.com/max/2250/0*iA2vNFI2BtyxtmVJ.png" alt="Image for post"></p>
<p>我们预先在水管网络的每个出口都插一块字牌，对应于每一个我们想让计算机认识的汉字。这时，因为输入的是“田”这个汉字，等水流流过整个水管网络，计算机就会跑到管道出口位置去看一看，是不是标记由“田”字的管道出口流出来的水流最多。如果是这样，就说明这个管道网络符合要求。如果不是这样，就调节水管网络里的每一个流量调节阀，让“田”字出口“流出”的水最多。</p>
<p>这下，计算机要忙一阵了，要调节那么多阀门！好在计算机的速度快，暴力的计算加上算法的优化，总是可以很快给出一个解决方案，调好所有阀门，让出口处的流量符合要求。</p>
<p><img src="https://miro.medium.com/max/2250/0*qJEO7uk-36RqndEL.png" alt="Image for post"></p>
<p>下一步，学习“申”字时，我们就用类似的方法，把每一张写有“申”字的图片变成一大堆数字组成的水流，灌进水管网络，看一看，是不是写有“申”字的那个管道出口流水最多，如果不是，我们还得再调整所有的阀门。这一次，要既保证刚才学过的“田”字不受影响，也要保证新的“申”字可以被正确处理。</p>
<p><img src="https://miro.medium.com/max/2250/0*MU5HgYbFRARwyTzU.png" alt="Image for post"></p>
<p>如此反复进行，直到所有汉字对应的水流都可以按照期望的方式流过整个水管网络。这时，我们就说，这个水管网络是一个<strong>训练好的深度学习模型了</strong>。当大量汉字被这个管道网络处理，所有阀门都调节到位后，整套水管网络就可以用来识别汉字了。这时，我们可以把调节好的所有阀门都“焊死”，静候新的水流到来。</p>
<p><img src="https://miro.medium.com/max/2250/0*yof1ZXCegXlMmBw4.png" alt="Image for post"></p>
<p>与训练时做的事情类似，未知的图片会被计算机转变成数据的水流，灌入训练好的水管网络。这时，计算机只要观察一下，哪个出水口流出来的水流最多，这张图片写的就是哪个字。</p>
<p><strong>深度学习大致就是这么一个用人类的数学知识与计算机算法构建起来的整体架构，再结合尽可能多的训练数据以及计算机的大规模运算能力去调节内部参数，尽可能逼近问题目标的半理论、半经验的建模方式。</strong></p>
<h1 id="传统机器学习-VS-深度学习"><a href="#传统机器学习-VS-深度学习" class="headerlink" title="传统机器学习 VS 深度学习"></a>传统机器学习 VS 深度学习</h1><p><strong>传统机器学习和深度学习的相似点</strong></p>
<p><img src="https://miro.medium.com/max/2250/0*IZS2sBbcC4Bq6oAz.png" alt="Image for post"></p>
<p>在数据准备和预处理方面，两者是很相似的。</p>
<p>他们都可能对数据进行一些操作：</p>
<ul>
<li>数据清洗</li>
<li>数据标签</li>
<li>归一化</li>
<li>去噪</li>
<li>降维</li>
</ul>
<p>对于数据预处理感兴趣的可以看看《<a href="https://easyai.tech/blog/ai-dataset-6-problem-solution/" target="_blank" rel="noopener">AI 数据集最常见的6大问题（附解决方案）</a>》</p>
<p><strong>传统机器学习和深度学习的核心区别</strong></p>
<p><img src="https://miro.medium.com/max/2250/0*nbVmEiRfR0mRoicm.png" alt="Image for post"></p>
<p>传统机器学习的特征提取主要依赖人工，针对特定简单任务的时候人工提取特征会简单有效，但是并不能通用。</p>
<p><u>深度学习的特征提取并不依靠人工，而是机器自动提取的。</u>这也是为什么大家都说深度学习的可解释性很差，因为有时候深度学习虽然能有好的表现，但是我们并不知道他的原理是什么。</p>
<h1 id="深度学习的优缺点"><a href="#深度学习的优缺点" class="headerlink" title="深度学习的优缺点"></a>深度学习的优缺点</h1><p><img src="https://miro.medium.com/max/2250/0*a-46X1jB7i79HT-h.png" alt="Image for post"></p>
<p><strong>优点1：学习能力强</strong></p>
<p>从结果来看，深度学习的表现非常好，他的学习能力非常强。</p>
<p><strong>优点2：覆盖范围广，适应性好</strong></p>
<p>深度学习的神经网络层数很多，宽度很广，理论上可以映射到任意函数，所以能解决很复杂的问题。</p>
<p><strong>优点3：数据驱动，上限高</strong></p>
<p>深度学习高度依赖数据，数据量越大，他的表现就越好。在图像识别、面部识别、<a href="https://easyai.tech/ai-definition/nlp/" target="_blank" rel="noopener">NLP</a> 等部分任务甚至已经超过了人类的表现。同时还可以通过调参进一步提高他的上限。</p>
<p><strong>优点4：可移植性好</strong></p>
<p>由于深度学习的优异表现，有很多框架可以使用，例如 <a href="https://easyai.tech/tensorflow-course-source/" target="_blank" rel="noopener">TensorFlow</a>、<a href="https://easyai.tech/PyTorch/" target="_blank" rel="noopener">Pytorch</a>。这些框架可以兼容很多平台。</p>
<p><strong>缺点1：计算量大，便携性差</strong></p>
<p>深度学习需要大量的数据很大量的算力，所以成本很高。并且现在很多应用还不适合在移动设备上使用。目前已经有很多公司和团队在研发针对便携设备的芯片。这个问题未来会得到解决。</p>
<p><strong>缺点2：硬件需求高</strong></p>
<p>深度学习对算力要求很高，普通的 CPU 已经无法满足深度学习的要求。主流的算力都是使用 <a href="https://easyai.tech/ai-definition/gpugraphics-processing-unit/" target="_blank" rel="noopener">GPU</a> 和 <a href="https://easyai.tech/ai-definition/tpu（tensor-processing-unit）/" target="_blank" rel="noopener">TPU</a>，所以对于硬件的要求很高，成本也很高。</p>
<p><strong>缺点3：模型设计复杂</strong></p>
<p>深度学习的模型设计非常复杂，需要投入大量的人力物力和时间来开发新的算法和模型。大部分人只能使用现成的模型。</p>
<p><strong>缺点4：没有”人性”，容易存在偏见</strong></p>
<p>由于深度学习依赖数据，并且可解释性不高。在训练数据不平衡的情况下会出现性别歧视、种族歧视等问题。</p>
<h1 id="4种典型的深度学习算法"><a href="#4种典型的深度学习算法" class="headerlink" title="4种典型的深度学习算法"></a>4种典型的深度学习算法</h1><p><img src="https://miro.medium.com/max/2250/0*Xjz6KC53Hz69laZX.png" alt="Image for post"></p>
<h1 id="卷积神经网络-—-CNN"><a href="#卷积神经网络-—-CNN" class="headerlink" title="卷积神经网络 — CNN"></a>卷积神经网络 — CNN</h1><p><a href="https://easyai.tech/ai-definition/cnn/" target="_blank" rel="noopener"><strong>CNN</strong></a> <strong>的价值：</strong></p>
<ol>
<li>能够<strong>将大数据量的图片有效的降维成小数据量(并不影响结果)</strong></li>
<li>能够保留图片的特征，类似人类的视觉原理</li>
</ol>
<p><strong>CNN 的基本原理：</strong></p>
<ol>
<li>卷积层 — 主要作用是保留图片的特征</li>
<li>池化层 — 主要作用是把数据降维，可以有效的避免过拟合</li>
<li>全连接层 — 根据不同任务输出我们想要的结果</li>
</ol>
<p><strong>CNN 的实际应用：</strong></p>
<ol>
<li>图片分类、检索</li>
<li>目标定位检测</li>
<li>目标分割</li>
<li>人脸识别</li>
<li>骨骼识别</li>
</ol>
<p>了解更多《<a href="https://easyai.tech/ai-definition/cnn/" target="_blank" rel="noopener">一文看懂卷积神经网络-CNN（基本原理+独特价值+实际应用）</a>》</p>
<h1 id="循环神经网络-—-RNN"><a href="#循环神经网络-—-RNN" class="headerlink" title="循环神经网络 — RNN"></a>循环神经网络 — RNN</h1><p><a href="https://easyai.tech/ai-definition/rnn/" target="_blank" rel="noopener">RNN</a> 是<strong>一种能有效的处理序列数据的算法</strong>。比如：文章内容、语音音频、股票价格走势…</p>
<p>之所以他能处理序列数据，是因为<strong>在序列中前面的输入也会影响到后面的输出，相当于有了“记忆功能”。但是 RNN 存在严重的短期记忆问题，长期的数据影响很小（哪怕他是重要的信息）。</strong></p>
<p>于是基于 RNN 出现了 <a href="https://easyai.tech/ai-definition/lstm/" target="_blank" rel="noopener">LSTM</a> 和 GRU 等变种算法。这些变种算法主要有几个特点：</p>
<ol>
<li>长期信息可以有效的保留</li>
<li>挑选重要信息保留，不重要的信息会选择“遗忘”</li>
</ol>
<p>RNN 几个典型的应用如下：</p>
<ol>
<li>文本生成</li>
<li>语音识别</li>
<li>机器翻译</li>
<li>生成图像描述</li>
<li>视频标记</li>
</ol>
<p>了解更多《<a href="https://easyai.tech/ai-definition/rnn/" target="_blank" rel="noopener">一文看懂循环神经网络-RNN（独特价值+优化算法+实际应用）</a>》</p>
<h1 id="生成对抗网络-—-GANs"><a href="#生成对抗网络-—-GANs" class="headerlink" title="生成对抗网络 — GANs"></a>生成对抗网络 — GANs</h1><p>假设一个城市治安混乱，很快，这个城市里就会出现无数的小偷。在这些小偷中，有的可能是盗窃高手，有的可能毫无技术可言。假如这个城市开始整饬其治安，突然开展一场打击犯罪的「运动」，警察们开始恢复城市中的巡逻，很快，一批「学艺不精」的小偷就被捉住了。之所以捉住的是那些没有技术含量的小偷，是因为警察们的技术也不行了，在捉住一批低端小偷后，城市的治安水平变得怎样倒还不好说，但很明显，城市里小偷们的平均水平已经大大提高了。</p>
<p>警察们开始继续训练自己的破案技术，开始抓住那些越来越狡猾的小偷。随着这些职业惯犯们的落网，警察们也练就了特别的本事，他们能很快能从一群人中发现可疑人员，于是上前盘查，并最终逮捕嫌犯；小偷们的日子也不好过了，因为警察们的水平大大提高，如果还想以前那样表现得鬼鬼祟祟，那么很快就会被警察捉住。为了避免被捕，小偷们努力表现得不那么「可疑」，而魔高一尺、道高一丈，警察也在不断提高自己的水平，争取将小偷和无辜的普通群众区分开。随着警察和小偷之间的这种「交流」与「切磋」，小偷们都变得非常谨慎，他们有着极高的偷窃技巧，表现得跟普通群众一模一样，而警察们都练就了「火眼金睛」，一旦发现可疑人员，就能马上发现并及时控制 — — 最终，我们同时得到了最强的小偷和最强的警察。</p>
<p><img src="https://miro.medium.com/max/2250/0*L7tBTFe4oHJ6pmWk.png" alt="Image for post"></p>
<p>了解更多《<a href="https://easyai.tech/ai-definition/gan/" target="_blank" rel="noopener">什么是生成对抗网络 — GAN？（基本概念+工作原理）</a>》</p>
<h1 id="深度强化学习-—-RL"><a href="#深度强化学习-—-RL" class="headerlink" title="深度强化学习 — RL"></a>深度强化学习 — RL</h1><p>强化学习算法的思路非常简单，以游戏为例，如果在游戏中采取某种策略可以取得较高的得分，那么就进一步「强化」这种策略，以期继续取得较好的结果。这种策略与日常生活中的各种「绩效奖励」非常类似。我们平时也常常用这样的策略来提高自己的游戏水平。</p>
<p>在 Flappy bird 这个游戏中，我们需要简单的点击操作来控制小鸟，躲过各种水管，飞的越远越好，因为飞的越远就能获得更高的积分奖励。</p>
<p>这就是一个典型的强化学习场景：</p>
<ul>
<li>机器有一个明确的小鸟角色 — — 代理</li>
<li>需要控制小鸟飞的更远 — — 目标</li>
<li>整个游戏过程中需要躲避各种水管 — — 环境</li>
<li>躲避水管的方法是让小鸟用力飞一下 — — 行动</li>
<li>飞的越远，就会获得越多的积分 — — 奖励</li>
</ul>
<p><img src="https://miro.medium.com/max/2250/0*PPQ2hIfYDkWLTZOr.png" alt="Image for post"></p>
<p>你会发现，强化学习和监督学习、无监督学习 最大的不同就是不需要大量的“数据喂养”。而是通过自己不停的尝试来学会某些技能。</p>
<p>了解更多：《<a href="https://easyai.tech/ai-definition/reinforcement-learning/" target="_blank" rel="noopener">一文看懂什么是强化学习？（基本概念+应用场景+主流算法）</a>》</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>深度学习属于机器学习的范畴，深度学习可以说是在传统神经网络基础上的升级，约等于神经网络。</p>
<p>深度学习和传统机器学习在数据预处理上都是类似的。核心差别在特征提取环节，深度学习由机器自己完成特征提取，不需要人工提取。</p>
<p><strong>深度学习的优点：</strong></p>
<ol>
<li>学习能力强</li>
<li>覆盖范围广，适应性好</li>
<li>数据驱动，上限高</li>
<li>可移植性好</li>
</ol>
<p><strong>深度学习的缺点：</strong></p>
<ol>
<li>计算量大，便携性差</li>
<li>硬件需求高</li>
<li>模型设计复杂</li>
<li>没有”人性”，容易存在偏见</li>
</ol>
<p><strong>深度学习的4种典型算法：</strong></p>
<ol>
<li>卷积神经网络 — CNN</li>
<li>循环神经网络 — RNN</li>
<li>生成对抗网络 — GANs</li>
<li>深度强化学习 — RL</li>
</ol>
]]></content>
      <categories>
        <category>转载文章</category>
      </categories>
      <tags>
        <tag>DLearning</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>白话深度学习与TensorFlow（3）——TensorFlow框架特性与安装</title>
    <url>/2020/07/19/%E7%99%BD%E8%AF%9D%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%8ETensorFlow%EF%BC%883%EF%BC%89%E2%80%94%E2%80%94TensorFlow%E6%A1%86%E6%9E%B6%E7%89%B9%E6%80%A7%E4%B8%8E%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h1 id="TensorFlow简介"><a href="#TensorFlow简介" class="headerlink" title="TensorFlow简介"></a>TensorFlow简介</h1><p>TensorFlow是一个<strong>采用数据流图</strong>，用于数值计算的开源软件库。</p>
<p><strong>节点（nodes）</strong>在图中表示数学操作，但也可以表示数据输入的起点/输出的终点，或者读取/写入持久变量（persistent variable）的终点。图中的线（edges）则表示在节点间相互联系的多维数据数组，即<strong>张量（tensor）</strong>。张量从图中流过的直观图像是这个工具取名为“TensorFlow”的原因。一旦输入端的所有张量准备好，节点将被分配到各种计算设备完成异步并行运算。</p>
<img src="http://reader.epubee.com/books/mobile/45/457619375a7312e6f1f9b7a8da94907a/Image00055.jpg" alt="TensorFlow" style="zoom: 50%;" />

<h1 id="对比其他框架"><a href="#对比其他框架" class="headerlink" title="对比其他框架"></a>对比其他框架</h1><ol>
<li>TensorFlow：深度学习最流行的库之一，是谷歌在深刻总结了其前身DistBelief的经验教训上形成的；它不仅便携、高效、可扩展，还能在不同计算机上运行：小到智能手机，大到计算机集群；它是一款轻量级的软件，可以立刻生成你的训练模型，也能重新实现它；TensorFlow有强大的社区、企业支持，因此它广泛用于从个人到企业、从初创公司到大公司等不同群体。</li>
<li>Caffe：卷积神经网络框架，专注于卷积神经网络和图像处理，是用C++语言写成的，执行速度非常快。</li>
<li>Torch：是一个专注于GPU实现的机器学习库，得到了像Facebook、谷歌、Twitter这样的大公司的研究团队的支持。</li>
<li>Nervana Neo：是一个高效的Python机器学习库，它能够在单个机器上使用多个GPU。</li>
<li>Theano：是一个用Python编写的极其灵活的Python机器学习库，用它定义复杂的模型相当容易，因此它在研究中极其流行。</li>
</ol>
<h1 id="其他特点"><a href="#其他特点" class="headerlink" title="其他特点"></a>其他特点</h1><ol>
<li><p>多环境与集群支持</p>
</li>
<li><p>TensorBoard——看得见的训练</p>
</li>
<li><p>TensorFlow Serving——模型</p>
</li>
</ol>
<h1 id="如何选择好的框架"><a href="#如何选择好的框架" class="headerlink" title="如何选择好的框架"></a>如何选择好的框架</h1><p>目前框架之间的差别主要体现在以下几个地方：</p>
<ol>
<li><p>性能方面</p>
<p>该属性主要由底层的实现语言决定，运行速度较快的仍旧是C/C++一类。但这并不碍事，主要影响效率的是样本数量，网络设计等方面。</p>
</li>
<li><p>社区活跃度</p>
<p>活跃的社区意味着有更多的人正在使用这样一个项目，会有更多的人贡献代码，提交Bug，遇到错误你也很容易找到前人踩坑留下的垫坑石。因而做起项目来风险也相对比较小，学习起来进步也会快一些。</p>
</li>
<li><p>语言</p>
<p>这几乎是最不重要的一个方面，因为不管什么语言，实现的框架大多都会支持Python的“驱动”，或者我们称接口。</p>
</li>
</ol>
<h1 id="安装TensorFlow"><a href="#安装TensorFlow" class="headerlink" title="安装TensorFlow"></a>安装TensorFlow</h1><p><a href="https://www.tensorflow.org/install?hl=zh-cn" target="_blank" rel="noopener">TensorFlow安装教程</a></p>
]]></content>
      <categories>
        <category>读书总结</category>
      </categories>
      <tags>
        <tag>DLearning</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>白话深度学习与TensorFlow（1）——初识机器学习</title>
    <url>/2020/07/18/%E7%99%BD%E8%AF%9D%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%8ETensorFlow%EF%BC%881%EF%BC%89%E2%80%94%E2%80%94%E5%88%9D%E8%AF%86%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="机器学习是什么"><a href="#机器学习是什么" class="headerlink" title="机器学习是什么"></a>机器学习是什么</h1><p>机器学习就是人类定义一定的计算机算法，让计算机根据输入的样本和一些人类的干预来总结并归纳其特征与特点，并用这些特征和特点与一定的学习目标形成映射关系，进而自动化地做出相应反应的过程。</p>
<p>机器学习的目的是让机器可以<strong>独立或至少半独立地</strong>进行相对复杂或者高要求的工作。不同于传统的算法依据事先编写好的代码执行，机器学习具有“一定的智能性”。</p>
<p>以监督学习的过程为例。首先，给与模型一定数量的<strong>训练样本</strong>（训练集），让模型根据这些训练样本进行<strong>训练</strong>，从而得到一个判断标准。之后，利用验证集<strong>验证</strong>该标准是否具有泛化性。</p>
<p>机器学习可以分为两种，分别是<strong>监督学习和无监督学习</strong>。</p>
<h2 id="聚类"><a href="#聚类" class="headerlink" title="聚类"></a>聚类</h2><p>聚类，是一种典型的“无监督学习”，是把物理对象或抽象对象的集合分组为由彼此类似的对象组成的多个类的分析过程。简单来说，就是一种<strong>归纳总结</strong>的思想。</p>
<p>比较常用的聚类算法有K-Means、DBSCAN等几种，<strong>基本思路都是利用每个向量之间的“距离”</strong>——空间中的欧氏距离或者曼哈顿距离，从远近判断是否从属于同一类别。</p>
<h2 id="回归"><a href="#回归" class="headerlink" title="回归"></a>回归</h2><p>回归，是一种“学习”方法。简单来说就是一种<strong>“由果索因”</strong>的过程，是一种归纳的思想——当我看到大量的事实所呈现的样态，我推断出原因或客观蕴含的关系是如何的。</p>
<p>常用的回归有两大类，分别是<strong>线性回归和非线性回归</strong>。</p>
<ol>
<li><p>线性回归</p>
<p>所谓线性回归，就是在观察和归纳样本的过程中认为向量和最终的函数值呈现线性的关系。而后设计这种关系为：</p>
<p>y=f（x）=wx+b</p>
<p>这里的w和x分别是1×n和n×1的矩阵，wx则指的是这两个矩阵的内积。</p>
<p>我们所要做的事情就是对w矩阵的内容和偏置b的内容求出一个<strong>使得Loss最小的解</strong>出来，越小就说明该映射关系描述越精确。Loss为一个全局范围内由f（x）映射得到的y和我真实观测到的那个y的差距加和，表达式如下：</p>
<p><img src="http://reader.epubee.com/books/mobile/45/457619375a7312e6f1f9b7a8da94907a/Image00006.jpg" alt="Loss函数"></p>
<div class="note info"><p>使用线性回归的前提是数据呈现出线性关系。否则，会产生欠拟合现象。 </p>
</div>
</li>
<li><p>非线性回归</p>
<p>非线性回归类中，在机器学习领域应用最多的当属逻辑回归。与线性回归不同，在这种模型中观察者假设的前提是y只有两种值：一种是1，一种是0，或者说“是”或“否”的这种判断。</p>
<p><img src="http://reader.epubee.com/books/mobile/45/457619375a7312e6f1f9b7a8da94907a/Image00009.jpg" alt="逻辑回归"></p>
<p>这里面的wx+b和前面线性回归中所说的wx+b是一个概念，都是指一个w矩阵和x做了内积再和偏置b做了加和。</p>
<p>令<strong>z = wx + b，则横轴是z，纵轴是y，</strong>那么函数图像如下：</p>
<p><img src="http://reader.epubee.com/books/mobile/45/457619375a7312e6f1f9b7a8da94907a/Image00011.jpg" alt="逻辑回归函数图像"></p>
<p>训练的过程跟普通线性回归也是一样的，只不过损失函数的形式不同。但是，它的损失函数的含义仍旧是表示这种拟合残差与待定系数的关系，并通过相应的手段进行迭代式的优化，最后通过逐步调整待定系数减小残差。</p>
</li>
</ol>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>分类，通常我们把分类算法叫做”分类器“。</p>
<p>分类的原理就相当于一个黑盒子，有个入口，有个出口。我们在入口丢进去一个“样本”，在出口<strong>期望得到一个分类的“标签”</strong>。分类的训练过程和回归的训练过程一样，都是极为套路化的程序。</p>
<ol>
<li>输入样本和分类标签</li>
<li>建立映射假说的某个y = f（x）的模型</li>
<li>求解出全局的损失函数Loss和待定系数w的映射关系，Loss = g（w）</li>
<li>通过迭代优化逐步降低Loss，最终找到一个w能使召回率和精确率满足当前场景需要。注意，这里尤其指在验证数据集上的表现。</li>
</ol>
<p>我们在编写代码教会分类器怎么做学习的时候，其实是在教它如何建立一种输入到输出的映射逻辑，以及让它自己调整这种逻辑关系，使得逻辑更为合理。而合理与否的判断也非常明确，那就是<strong>召回率</strong><sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>和<strong>精确率</strong><sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>两个指标。</p>
<h2 id="传统机器学习与深度学习"><a href="#传统机器学习与深度学习" class="headerlink" title="传统机器学习与深度学习"></a>传统机器学习与深度学习</h2><p>机器学习可以粗略地分为传统的机器学习和深度学习。</p>
<p>传统的机器学习通常是需要人提前先来做特征提取，把提取过的特征向量化后再丢给模型去训练，这里<strong>人要做相当的前置工作</strong>。并且传统机器学习在工作的过程中具<strong>有非常好的解释特性</strong>，或者说你知道模型在做什么，处理的是什么特征，其中任何一个指标值的大小变化的意义会有良好的解释。而且，传统机器学习在训练的过程中<strong>需要很少的样本向量</strong>，通常都是百级或者千级就够了，这对于深度学习来说也是无法做到的——它需要数以万计的样本来做训练。</p>
<p>深度学习通常可以采用End-to-End的学习方式，输入的内容只需要做很少的一些归一化（normalization）、白化（whitening）等处理就可以丢给模型去训练，通常<strong>不需要人来做特征提取的工作</strong>。而这个特征提取的动作可以由整个深度学习的网络模型帮我们自动完成。</p>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">就是查全率，即检索出的相关样本和样本库（待测对象库）中所有的相关样本的比率</span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;">就是查准率，检索出的相关样本数与检索出的样本总数的比率</span><a href="#fnref:2" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>读书总结</category>
      </categories>
      <tags>
        <tag>DLearning</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>白话深度学习与TensorFlow（4）——前馈神经网络</title>
    <url>/2020/07/21/%E7%99%BD%E8%AF%9D%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%8ETensorFlow%EF%BC%884%EF%BC%89%E2%80%94%E2%80%94%E5%89%8D%E9%A6%88%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h1 id="前馈神经网络"><a href="#前馈神经网络" class="headerlink" title="前馈神经网络"></a>前馈神经网络</h1><p>在该神经网络中，各神经元从输入层开始，接收前一级输入，并输入到下一级，直至输出层。整个网络中无反馈，可用一个有向无环图（directed acyclic graph，DAG）表示。</p>
<p>前馈神经网络有两种：一种叫Back Propagation Networks——<strong>反向传播网络（以下简称BP网络）</strong>，一种叫RBF Network——<strong>径向基函数神经网络</strong>。</p>
<h2 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h2><p><img src="http://reader.epubee.com/books/mobile/45/457619375a7312e6f1f9b7a8da94907a/Image00070.jpg" alt="BP网络结构"></p>
<p>在上图的两种网络都是前馈神经网络结构。一个向量从左边进入，经过网络的运算从右边产生一个输出结果。</p>
<h2 id="线性回归的训练"><a href="#线性回归的训练" class="headerlink" title="线性回归的训练"></a>线性回归的训练</h2><ol>
<li><p>样本</p>
<p>假设我们具有一堆样本数据（x，y），这些样本数据符合线性关系：y = wx + b，之后的问题便是求解待定系数w和b。</p>
</li>
<li><p>开始训练</p>
<p>目前的问题是求解y = wx + b中的w和b。假设在拟合的过程中有一个参数e，表示误差，则线性关系可表示为：<strong>y = wx + b + e</strong></p>
<p>当我取定任何一个w和b的时候，只要代入一个x和对应的y就一定会产生一个e来表示这个误差。</p>
<p><img src="http://reader.epubee.com/books/mobile/45/457619375a7312e6f1f9b7a8da94907a/Image00114.jpg" alt="误差"></p>
<p>我们将n（假设n=10）个e的大小做加和来表示一个全局的误差总量，表达式如下：</p>
<p><img src="http://reader.epubee.com/books/mobile/45/457619375a7312e6f1f9b7a8da94907a/Image00115.jpg" alt="误差总量"></p>
<p><strong>注意</strong>，e表示的是误差，也就是说e是正数是误差，e是负数也是误差，这种误差我们称为<strong>残差</strong>。既然e本身是正是负都应该算作残差，那么让其内部正负抵消显然不合适，这种情况下应该把每个e都做一个非负的处理，或者取绝对值或者取平方，都能达到类似的效果。我们在这里就取平方看看会有什么结果。</p>
<p><img src="http://reader.epubee.com/books/mobile/45/457619375a7312e6f1f9b7a8da94907a/Image00116.jpg" alt="残差"></p>
<p>对于残差平方展开后得到的多项式中，x和y都是已知的样本数据，故Loss可以改写为如下形式：</p>
<p><img src="http://reader.epubee.com/books/mobile/45/457619375a7312e6f1f9b7a8da94907a/Image00117.jpg" alt="全局Loss函数"></p>
<p>其中的A，B，C，D，E，F全部都是常数系数，w和b是未知数。</p>
<p>现在要做一件事，那就是找到一个比较好的w和一个比较好的b，使得整个Loss尽可能小，越接近0越好，说明拟合的误差越小。</p>
<p>我们可以通过迭代不断地学习，来逐渐逼近这个模型中待定系数w和b的最佳值位置。首先初始化一个w<del>0</del>和一个b<del>0</del>，将其带入到</p>
<p><img src="http://reader.epubee.com/books/mobile/45/457619375a7312e6f1f9b7a8da94907a/Image00119.jpg" alt="Loss"></p>
<p>得到一个值Loss<del>0</del>。这个时候（w<del>0</del>，b<del>0</del>，Loss<del>0</del>）会出现在Loss函数图像上的某个位置，这个位置可能距离我们要找的极值点还差很多，所以要继续迭代。我们可以使用<strong>梯度下降</strong>的方法来求解，这是一种用来<strong>解决凸优化问题</strong>的通用方法。梯度下降的方法如下：</p>
<p><img src="http://reader.epubee.com/books/mobile/45/457619375a7312e6f1f9b7a8da94907a/Image00121.jpg" alt="梯度下降法"></p>
<p>这表示的是一个更新逻辑过程，xn+1 和xn 分别表示两个临近迭代中的x值，xn+1 是xn 更新后的下一次迭代的值。其中希腊字母η，称为“学习率”，是挪动“步长”的基数，设得大就挪动得多，设得小就挪动得少，在学习伊始由编程序的人给赋值。</p>
<p>一轮一轮进行迭代，直到每次更新的值非常小，损失值不在明显减少就可以判断为训练结束。此时得到的（w，b）值就是我们要求的模型。</p>
<div class="note info"><p>注意：不求梯度（偏导数）的情况下，通过改变w或b的值是一定能够比较出来移动的方向的，但是问题是不知道移动多少比较适宜。而有了偏导数与学习率η的乘积后，当这个点逐步接近“碗底”的时候，偏导数也随之降低，移动的步伐也会慢慢减小，收敛更为平缓，不会轻易出现“步子太大”而越过最低点的情况。</p>
</div>
</li>
<li><p>模型工作</p>
<p>把一个输入的x带入到训练好的y = wx + b中，使它输出一个y。</p>
</li>
</ol>
<h2 id="神经网络的训练"><a href="#神经网络的训练" class="headerlink" title="神经网络的训练"></a>神经网络的训练</h2><p>有一两层的神经网络如下：</p>
<p><img src="http://reader.epubee.com/books/mobile/45/457619375a7312e6f1f9b7a8da94907a/Image00162.jpg" alt="神经网络"></p>
<p>该网络用函数表达式去写的话如下：</p>
<p><img src="http://reader.epubee.com/books/mobile/45/457619375a7312e6f1f9b7a8da94907a/Image00163.jpg" alt="函数表示"></p>
<p>把整个网络里所有的待定系数wh 、bh 、wo 、bo 都初始化一个值，然后照猫画虎地按照刚才的套路，定义一个描述误差的损失函数，然后将wh 、bh 、wo 、bo 逐步变化，直到损失函数减小到足够小就OK了。</p>
]]></content>
      <categories>
        <category>读书总结</category>
      </categories>
      <tags>
        <tag>DLearning</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>阿飞学Linux——（0）计算机概论</title>
    <url>/2020/06/25/%E9%98%BF%E9%A3%9E%E5%AD%A6Linux%E2%80%94%E2%80%94%EF%BC%880%EF%BC%89%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A6%82%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="什么是电脑"><a href="#什么是电脑" class="headerlink" title="什么是电脑"></a>什么是电脑</h1><p>电脑是指接受用户输入指令与数据，经由cpu等数学与逻辑单元运算处理后，以产生或储存成有用的信息。</p>
<h2 id="计算机硬件的五大单元"><a href="#计算机硬件的五大单元" class="headerlink" title="计算机硬件的五大单元"></a>计算机硬件的五大单元</h2><p>计算机是由五个单元组成的，包括<strong>输入单元，输出单元，cpu内部的控制单元，算数逻辑单元与内存</strong>五个部分。</p>
<p>cpu内部的控制单元负责协调周边元件与各单元间的工作，而算术逻辑单元负责程序运算与逻辑判断。</p>
<p>故计算机的工作流程是，用户利用输入单元输入数据，之后数据流入内存，cpu从内存读取数据进行运算后，将结果写回内存后送给输出单元显示。</p>
<a id="more"></a>

<p><img src="http://linux.vbird.org/linux_basic/0105computers/computer02.gif" alt="电脑的五大单元"></p>
<h2 id="CPU的架构"><a href="#CPU的架构" class="headerlink" title="CPU的架构"></a>CPU的架构</h2><p>cpu的架构分为两种，分别是精简指令集（RISC）与复杂指令集（CISC）。</p>
<p>精简指令集较为精简，每个指令的执行时间较短，完成的动作单纯，执行性能较佳；而复杂指令集包含较多的指令，指令的执行较复杂，花费时间较长。</p>
<h2 id="电脑上常用的计算单位"><a href="#电脑上常用的计算单位" class="headerlink" title="电脑上常用的计算单位"></a>电脑上常用的计算单位</h2><ol>
<li><p>容量单位</p>
<p>电脑在存取数据时是以Byte为单位的，而1 Byte = 8 bits。</p>
<p>常见的单位转换如下</p>
<table>
<thead>
<tr>
<th>进位制</th>
<th>Kilo</th>
<th>Mega</th>
<th>Giga</th>
<th>Tera</th>
</tr>
</thead>
<tbody><tr>
<td>二进制</td>
<td>1024B</td>
<td>1024K</td>
<td>1024M</td>
<td>1024G</td>
</tr>
</tbody></table>
</li>
<li><p>速度单位</p>
<p>CPU的运算速度常使用MHz或GHz之类的单位。而网络传输方面，常使用的单位为Mbps即Mbits per second。</p>
</li>
</ol>
<h1 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h1><h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><p>不同的CPU型号具有不同的脚位，因此能够搭配的主板芯片组也不同。</p>
<p>CPU内部含有微指令集，不同的微指令集使CPU具有不同的工作效率。除此之外，CPU性能的比较还与CPU的频率有很大的关系。</p>
<ul>
<li><p>CPU的工作频率：外频与倍频</p>
<p>早期的CPU架构通过北桥来链接系统最重要的CPU，内存与显卡设备。由于所有的设备都通过北桥来链接，故每个设备的工作频率要相同。但是CPU的运算速度远高于其他设备，故为了迎合其他设备的速度，需要在CPU内部进行再加速，于是就有了外频与倍频。外频*倍频，所得到的就是CPU的真实频率速度。不过，由于速度被北桥所卡死了，故目前已经取消了北桥，取而代之的是，将内存控制器整合到CPU内部，使得CPU可以直接与内存等设备分别进行沟通。</p>
<p><em>倍频是固定好的，故进行超频时，修改的是外频。</em></p>
</li>
<li><p>32位与64位的CPU</p>
<p>CPU每次能够从内存中读取数据进行处理的数据量称为字组大小，字组大小依据CPU的设计有32位和64位。</p>
</li>
</ul>
<h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>CPU所使用的数据都是来自于内存。个人电脑的内存主要为动态随机存取内存DRAM，是一种挥发性内存。DRAM又可以分为SDRAM和DDR SDRAM两种。DDR是所谓的双倍数据传送速度，它可以在一次工作周期中进行两次数据传送。</p>
<ul>
<li><p>多通道设计</p>
<p>传统的总线宽度一般为64位，为了加大该宽度，因此芯片组厂商将两个内存汇整在一起，如果一支内存是64位，则两支内存可以达到128位，这就是双通道设计。</p>
</li>
<li><p>DRAM与SRAM</p>
<p>由于CPU与内存之间的通信还得要经过内存控制器，故如果将部分数据放在CPU中的话，可以提高性能。由此引入了高速缓存，但是DRAM无法达到所要求的频率速度，故需要使用SRAM（静态随机存取内存）。</p>
<p><img src="http://linux.vbird.org/linux_basic/0105computers/computer07.gif" alt="高速缓存作用"></p>
</li>
<li><p>ROM</p>
<p>ROM也叫只读存储器，是一种非挥发性的内存。很多的固件，通常就是写入ROM中</p>
</li>
</ul>
<h2 id="显卡"><a href="#显卡" class="headerlink" title="显卡"></a>显卡</h2><p>显卡对于图像影像的显示扮演了关键的角色。</p>
<p>显卡上会有一个内存的容量，称为显存，它的容量影响到屏幕分辨率于色彩深度。而随着3D游戏的流行，显卡运算能力愈发重要，因此显卡会内嵌一个3D加速芯片，这就是所谓的GPU。目前主流的显卡规格是PCI-e，它拥有更快的传输带宽。</p>
<table>
<thead>
<tr>
<th>规格</th>
<th>1x带宽</th>
<th>16x带宽</th>
</tr>
</thead>
<tbody><tr>
<td>PCIe 1.0</td>
<td>250MB/s</td>
<td>4GB/s</td>
</tr>
<tr>
<td>PCIe 2.0</td>
<td>500MB/s</td>
<td>8GB/s</td>
</tr>
<tr>
<td>PCIe 3.0</td>
<td>~1GB/s</td>
<td>~16GB/s</td>
</tr>
<tr>
<td>PCIe 4.0</td>
<td>~2GB/s</td>
<td>~32GB/s</td>
</tr>
</tbody></table>
<h2 id="硬盘"><a href="#硬盘" class="headerlink" title="硬盘"></a>硬盘</h2><p>硬盘在运行时，主轴马达让盘片转动，然后机械手臂可伸展让磁头在盘片上进行读写。一个硬盘内会有多个盘片。盘片上的数据如下图所示：</p>
<p><img src="http://linux.vbird.org/linux_basic/0105computers/Disktructure.jpg" alt="盘片上的数据格式"></p>
<p>盘片上的每个小区块，称之为<strong>扇区</strong>。同一个同心圆的扇区组合成的圆称为<strong>磁道</strong>。而所有盘片上面的同一个磁道组合成了<strong>柱面</strong>。</p>
<ul>
<li><p>传输接口</p>
<ul>
<li><p>SATA接口</p>
<p>目前SATA已经发展到了第三代，SATA 3.0的理论接口速度可以达到600 MByte/s。</p>
</li>
<li><p>USB接口</p>
<p>如果磁盘是外接式的接口，那么跟主板链接的很可能就是USB接口。目前USB 3.1的理论传输速度可以达到1000 MByte/s，但是实际上并不可能达到。</p>
</li>
</ul>
</li>
<li><p>固态硬盘SSD</p>
<p>传统的硬盘读写数据延迟较高，因此产生了固态硬盘，它没有寻道时间和旋转延迟，可以通过内存直接读写，大大提高了传输效率。</p>
</li>
</ul>
<h2 id="扩展卡与接口"><a href="#扩展卡与接口" class="headerlink" title="扩展卡与接口"></a>扩展卡与接口</h2><p>多信道的卡，例如x8的卡可以安装在少信道的插槽上，如x4的插槽。只是如此这般的话，这张卡的极限性能会下降。</p>
<h2 id="主板"><a href="#主板" class="headerlink" title="主板"></a>主板</h2><ul>
<li><p>发挥扩展卡性能需要考虑插槽的位置</p>
<p>如果我们将卡安装在跟CPU直接相连的那几个插槽上，可以得到最佳性能，但是如果安装在与南桥相连接的插槽上，那么扩展卡的数据要先进入南桥争抢带宽，之后再通过DMI 2.0将数据传给CPU。DMI 2.0的传输速度远远低于PCIe 2.0x8的传输速度，由此导致了性能瓶颈。</p>
</li>
<li><p>CMOS与BIOS</p>
<p>CMOS是嵌入在主板上面的存储器，主要功能为记录主板上面的重要参数，包括系统时间，CPU电压与频率等。</p>
<p>BIOS是主板上的固件，在开机时计算机主动执行的第一个程序，负责载入CMOS中的参数，并调用储存设备中的开机程序。</p>
</li>
<li><p>连接周边设备的接口</p>
<p><img src="http://linux.vbird.org/linux_basic/0105computers/connect02.jpg" alt="链接周边设备接口"></p>
<ul>
<li>USB接口：USB 3.0为蓝色的插槽颜色。</li>
</ul>
</li>
</ul>
<h1 id="数据表示方式"><a href="#数据表示方式" class="headerlink" title="数据表示方式"></a>数据表示方式</h1><h2 id="数字系统"><a href="#数字系统" class="headerlink" title="数字系统"></a>数字系统</h2><p>二进制是计算机的基础。</p>
<p>二进制与十进制的转换如下：</p>
<p>1101 = 1 * 2^3^ + 1 * 2^2^ + 0 * 2^1^ + 1 * 2^0^</p>
<p>十进制转二进制如下：</p>
<p><img src="http://linux.vbird.org/linux_basic/0105computers/number_01.gif" alt="十进制转二进制方法"></p>
<h2 id="文字编码系统"><a href="#文字编码系统" class="headerlink" title="文字编码系统"></a>文字编码系统</h2><p>计算机上文字的存储采用的文字编码系统的方式来实现的。具体实现如下图所示：</p>
<p><img src="http://linux.vbird.org/linux_basic/0105computers/word_01.gif" alt="文字编码系统"></p>
<p>常用的英文编码表是ASCII编码，在该编码中，每个符号占1 Bytes的记录，故有2^8^ = 256种变化。</p>
<h1 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h1><h2 id="机器程序与编译程序"><a href="#机器程序与编译程序" class="headerlink" title="机器程序与编译程序"></a>机器程序与编译程序</h2><p>对于人类而言直接编写机器程序是不现实的，因此产生了高级程序语言。利用高级程序语言编写代码后，交与编译器进行编译后得到机器码，这样简化了写代码的工作。</p>
<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><p>OS其实也是一组程序，这组程序的重点在于管理电脑的所有活动以及驱动系统中的所有硬件。但是，要命令OS驱动硬件工作，必须有应用程序的帮助。</p>
<ul>
<li><p>OS核心</p>
<p>OS核心负责管控硬件以及提供合理的电脑系统资源分配。核心程序是参考硬件编写的，故同一个OS程序不能够在不同的硬件架构下运行。当硬件发生变动时，核心程序也要做出调整。并且核心程序是受保护的，不能被用户直接调用。因此，OS提供了系统调用接口，使得用户可以通过该接口调用核心功能，从而编写应用程序来完成复杂的工作。</p>
<p><img src="http://linux.vbird.org/linux_basic/0105computers/os_01.gif" alt="OS的角色"></p>
</li>
<li><p>驱动程序</p>
<p><img src="http://linux.vbird.org/linux_basic/0105computers/computer_driver.png" alt="驱动程序与OS的关系"></p>
<p>OS必须能够驱动硬件，如此应用程序才能够使用该硬件功能。通常OS会提供开发接口，让开发商制作他们的驱动程序。要使用新硬件功能，必须要安装合适的驱动程序。</p>
</li>
</ul>
<h2 id="应用程序"><a href="#应用程序" class="headerlink" title="应用程序"></a>应用程序</h2><p>应用程序时参考OS提供的开发接口所开发出来的软件，这些软件可以让用户操作，从而达到某些电脑的功能利用。 </p>
<h1 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h1><ol>
<li><p>全世界目前跑的最快的计算机（2020年6月23日）</p>
<ul>
<li>名称：富岳</li>
<li>系统名称：Red Hat </li>
<li>所在位置：日本</li>
<li>使用的CPU型号与规格：64位处理器A64FX，采用ARM架构</li>
<li>总共使用的CPU数量：15W</li>
</ul>
</li>
<li><p>Intel i7 4790 CPU的信息</p>
<ul>
<li>与南桥沟通的DMI带宽：5 GT/s</li>
<li>第二层高速缓存容量：8 MB</li>
<li>最大PCIe信道数量：16</li>
<li>主板上面PCIe插槽的数量限制：1x16,2x8,1x8+2x4</li>
</ul>
</li>
<li><p>Intel SSD 520相关信息</p>
<ul>
<li>连接接口：SATA 3.0 6 Gb/s</li>
<li>最大读写速度：读——550 MB/s，写——520 MB/s</li>
<li>最大随机读写数据：读——25000 IOPS，写——40000 IOPS</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>白话深度学习与TensorFlow（2）——初识深度学习</title>
    <url>/2020/07/19/%E7%99%BD%E8%AF%9D%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%8ETensorFlow%EF%BC%882%EF%BC%89%E2%80%94%E2%80%94%E5%88%9D%E8%AF%86%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="深度学习是什么"><a href="#深度学习是什么" class="headerlink" title="深度学习是什么"></a>深度学习是什么</h1><p>要了解深度学习必须先了解神经网络。</p>
<h2 id="神经网络是什么"><a href="#神经网络是什么" class="headerlink" title="神经网络是什么"></a>神经网络是什么</h2><p>神经网络是一种人类由于受到生物神经细胞结构启发而研究出的一种算法体系。神经网络的最基本组成单元——神经元。</p>
<h3 id="神经元"><a href="#神经元" class="headerlink" title="神经元"></a>神经元</h3><p>一个最简单的神经元如下图所示：</p>
<p><img src="http://reader.epubee.com/books/mobile/45/457619375a7312e6f1f9b7a8da94907a/Image00018.jpg" alt="神经元"></p>
<p>有一个输入，一个输出，所以它所表达的含义跟一个普通的函数没有什么区别。不过请注意，现在我们使用的<strong>神经元通常有两个部分组成，一个是“线性模型”，另一个是“激励函数”</strong>。</p>
<ol>
<li><p>线性模型</p>
<p>假设该神经元的输入为一个n维向量，那么我们可以建立一个有n个输入项的神经元f（x1 ，x2 ，…，xn ），设输出函数值output，则output = f（x），我们可以把该函数的处理写做：<strong>f（x）=wx+b</strong>。</p>
<p>这种方式也是神经元最核心部分对x所做的线性处理，其中x是一个1×n的矩阵，而w是一个n×1的权重矩阵，b是偏置项。</p>
</li>
<li><p>激励函数</p>
<p>也称作激活函数。激励函数在一个神经元当中跟随在f（x）= wx + b函数之后，用来加入一些非线性的因素。激励函数在神经元中的作用如下图所示：</p>
<p><img src="http://reader.epubee.com/books/mobile/45/457619375a7312e6f1f9b7a8da94907a/Image00030.jpg" alt="激励函数"></p>
</li>
</ol>
<h3 id="激励函数"><a href="#激励函数" class="headerlink" title="激励函数"></a>激励函数</h3><p>激励函数有很多，但是常用的并不多，主要有以下几种：</p>
<ol>
<li><p>sigmoid函数</p>
<p>定义如下：</p>
<p><img src="http://reader.epubee.com/books/mobile/45/457619375a7312e6f1f9b7a8da94907a/Image00026.jpg" alt="sigmoid函数"></p>
<p>或者可以写成如下形式：</p>
<p><img src="http://reader.epubee.com/books/mobile/45/457619375a7312e6f1f9b7a8da94907a/Image00027.jpg" alt="sigmoid函数2"></p>
<p>函数图像如下：</p>
<p><img src="http://reader.epubee.com/books/mobile/45/457619375a7312e6f1f9b7a8da94907a/Image00028.jpg" alt="sigmoid函数图像"></p>
<p>该图中横轴为z，纵轴为f（z）。可见该激励函数将激励值最终投射到了0和1两个值上。通过这种方式引入了非线性因素。其中的“1”表示完全激活的状态，“0”表示完全不激活的状态，其他各种输出值就介于两者之间，表示其激活程度不同。</p>
<div class="note info"><p>为什么要引入非线性因素？</p>
<p>因为最终用一个大的函数“网络”去拟合一个对应的关系的时候你会发现，如果仅有线性函数来拟合的话，那么拟合的结果一定仅仅包含各种各样的线性关系。一旦这个客观的、我们要求解的关系中本就含有非线性关系的话，那么这个网络必定严重欠拟合。</p>
</div>
</li>
<li><p>Tanh函数</p>
<p>定义如下：</p>
<p><img src="http://reader.epubee.com/books/mobile/45/457619375a7312e6f1f9b7a8da94907a/Image00031.jpg" alt="双曲正切函数"></p>
<p>函数图像如下：</p>
<p><img src="http://reader.epubee.com/books/mobile/45/457619375a7312e6f1f9b7a8da94907a/Image00032.jpg" alt="函数图像"></p>
<p>Tanh函数是把输入值投射到-1和1上去。其中“-1”表示完全不激活，“1”表示完全激活，中间其他值也是不同的激活程度的描述。<strong>除了映射区间不同以外，跟Sigmoid似乎区别不是很大。</strong></p>
</li>
<li><p>ReLU函数</p>
<p>定义为：y = max（x，0）。</p>
<p>函数图像如下：</p>
<p><img src="http://reader.epubee.com/books/mobile/45/457619375a7312e6f1f9b7a8da94907a/Image00033.jpg" alt="ReLU函数图像"></p>
<p>大部分的卷积神经网络中喜欢使用该激励函数。</p>
<p>这个函数的原点左侧部分斜率为0，在右侧则是一条斜率为1的直线，x小于0时输出一律为0，x大于0时输出就是输入值。</p>
</li>
</ol>
<h3 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h3><p><strong>多个神经元首尾连接形成</strong>一个类似网络的结构来协同工作的时候，那就可以被称为神经网络了。对于该网络必须有多少层，每层有多少个神经元结点，并没有做出明确规定，而是根据不同的场景依据经验与相关理论进行尝试，最后得到一个适应当前场景的网络设计。</p>
<p>神经网络的结构通常可以分为以下几层：输入层，隐藏层，输出层。如下图所示：</p>
<p><img src="http://reader.epubee.com/books/mobile/45/457619375a7312e6f1f9b7a8da94907a/Image00035.jpg" alt="神经网络结构"></p>
<p><strong>输入层</strong>在整个网络的最前端部分，直接接受输入的向量，它不对数据做任何处理，<strong>该层通常不计入层数</strong>。</p>
<p><strong>隐藏层</strong>可以有一层或多层。</p>
<p><strong>输出层</strong>是最后一层用来输出整个网络处理的值，这个值可能是一个分类向量值，也可能是一个类似线性回归那样产生的连续的值，也可能是别的复杂类型的值或者向量，根据不同的需求输出层的构造也不尽相同。</p>
<h2 id="深度神经网络"><a href="#深度神经网络" class="headerlink" title="深度神经网络"></a>深度神经网络</h2><p>深度学习（Deep Learning）就是<strong>基于深度神经网络的学习</strong>。这个Deep指的是神经网络的深度。</p>
<p>要注意，深度学习并不是在任何情况下都比传统机器学习表现好。</p>
<h2 id="深度学习为什么这么强"><a href="#深度学习为什么这么强" class="headerlink" title="深度学习为什么这么强"></a>深度学习为什么这么强</h2><p>深度神经网络能够通过大量的线性分类器和非线性关系的组合来完成平时非常棘手的线性不可分的问题。</p>
<h3 id="不用再提取特征"><a href="#不用再提取特征" class="headerlink" title="不用再提取特征"></a>不用再提取特征</h3><p>在神经网络中，由于巨量的线性分类器的堆叠（并行和串行）以及卷积网络的使用，它对噪声的忍耐能力、对多通道数据上投射出来的不同特征偏向的敏感程度会自动重视或者忽略。这样我们在处理的时候，人类所需要使用的技巧就没有那么高要求了，也就是我们通常所说的End-to-End<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>的训练方式。</p>
<h3 id="处理线性不可分"><a href="#处理线性不可分" class="headerlink" title="处理线性不可分"></a>处理线性不可分</h3><p>神经网络还有一个最神奇的地方，那就是用大量的线性分类器的堆叠使得整个模型可以将线性不可分的问题变得可分。</p>
<p>随着维度的加大，深度的加深，所能描述的分类器的复杂程度也会随之增加，所以传统分类模型中无法通过简单的线性分类器和非线性分类器处理的复杂学习场景（例如图形、视频、音频等）就能够通过海量<strong>分类器的叠加</strong>来实现。</p>
<p>例如，在二维空间中有这样一个不规则的四边形，如果我们想用一条线（一个线性分类器）把它分开，并保证其一侧是这个四边形内所有的点，我们称为“类别1”，另一侧是其他的点，我们称为“类别0”，这简直是不可能的，因为不管怎么画，这一条线都会使得其中至少有一个类非常“不纯”。</p>
<p><img src="http://reader.epubee.com/books/mobile/45/457619375a7312e6f1f9b7a8da94907a/Image00041.jpg" alt="图1"></p>
<p>解决方法是画4条线即可。</p>
<p><img src="http://reader.epubee.com/books/mobile/45/457619375a7312e6f1f9b7a8da94907a/Image00042.jpg" alt="图2"></p>
<p>用这4条线把它围起来，也就是必须同时满足4个分类器的1分类标准才算是我们要约束的1分类——每条直线的表达式都是形如f（x）=wx+b的线性分类器。</p>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">指那些不经过人为处理，直接把输入和期望输出作为网络训练的工作模式的训练方法。这种方法通常需要的样本数量极大。</span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>读书总结</category>
      </categories>
      <tags>
        <tag>DLearning</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>阿飞学Linux——（1）初识Linux</title>
    <url>/2020/06/27/%E9%98%BF%E9%A3%9E%E5%AD%A6Linux%E2%80%94%E2%80%94%EF%BC%881%EF%BC%89%E5%88%9D%E8%AF%86Linux/</url>
    <content><![CDATA[<h1 id="初识Linux"><a href="#初识Linux" class="headerlink" title="初识Linux"></a>初识Linux</h1><h2 id="什么是Linux"><a href="#什么是Linux" class="headerlink" title="什么是Linux"></a>什么是Linux</h2><p>Linux是一种OS，于1991年，由芬兰的Linus Torvalds开发而成，具有“可移植性”和良好的稳定性。</p>
<h2 id="GNU计划，自由软件与开放源代码"><a href="#GNU计划，自由软件与开放源代码" class="headerlink" title="GNU计划，自由软件与开放源代码"></a>GNU计划，自由软件与开放源代码</h2><p>将源代码连同软件程序释出的举动，在GNU计划的范畴之内被称为自由软件运动。同时为了防止自由软件被他人做成专利软件，Stallman将所有GNU与FSF开发出来的软件挂上了GPL的版权宣告——自由软件是一种自由的权力，并非是“价格”。</p>
<a id="more"></a>

<p>自由软件具有如下几个特点：取得软件与源代码，复制，修改，再发行，回馈，不能修改授权，不能单纯贩卖。</p>
<p>开放源代码（Open Source，简称开源软件）是指具有如下特点的软件：公布源代码且用户具有修改权；任意的再散布；允许修改或衍生作品；不可限制某些个人或团体的使用权；不可限制某些领域的应用；不可具有排他条款；</p>
<p>可见，GPL自由软件也是开源软件的一种。</p>
<h1 id="Linux的发展"><a href="#Linux的发展" class="headerlink" title="Linux的发展"></a>Linux的发展</h1><p>由于Minix无法满足使用者的功能需求，故Linus Torvalds参考Minix，编写了一个可以运行于386机器上的OS核心，即Linux。Linux完全相容于Unix，在Unix上运行的程序或软件，也可以在Linux上运行。Linus鼓励更多的开发人员共同参与到Linux的开发中。</p>
<p>为了应对程序码加入的状况，于是Linux便逐渐发展成具有模块的功能！亦即是将某些功能独立出于核心外，在需要的时候才载入到核心中。如此一来，如果有新的硬件驱动程序或者其他协定的程序码进来时，就可以模块化，大大的增加了Linux核心的可维护能力！</p>
<h2 id="Linux的核心版本"><a href="#Linux的核心版本" class="headerlink" title="Linux的核心版本"></a>Linux的核心版本</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">3.10.0 - 123.e17.x86_64</span><br><span class="line">主版本.次版本.释出版本 - 修改版本</span><br></pre></td></tr></table></figure>

<p>在2.6.x版本之前，Torvalds将核心的发展趋势分为两股</p>
<ul>
<li>主，次版本为奇数：发展中版本</li>
<li>主，次版本为偶数：稳定版本</li>
</ul>
<p>不过在3.0版本推出之后，这种以奇数，偶数分类的编号格式就失效了。转而以主线版本和长期维护版本分类。从3.0版本开始，核心主要依据主线版本来开发，开发完毕后往下一个主线版本进行，如3.10就是在3.9的基础下开发出来的新的主线版本。而旧的主线版本有两种处理方式，一是结束开发，而是转为长期维护版本。</p>
<p>要判断Linux核心是否为长期支持的版本，可以使用<code>uname -r</code> 来查阅核心版本，之后对照链接<a href="https://www.kernel.org/releases.html" target="_blank" rel="noopener">https://www.kernel.org/releases.html</a>的数据来分析。<strong>要注意，Linux distributions的版本号不等同于Linux kernel的版本。</strong></p>
<h2 id="Linux-distributions"><a href="#Linux-distributions" class="headerlink" title="Linux distributions"></a>Linux distributions</h2><p>为了帮助一般的用户使用Linux，许多商业公司或非盈利团体，就将Linux核心与可运行的软件整合起来，加上自己具有创意的工具程序，该工具程序可以让使用者以光盘/dvd或者通过网络直接安装/管理Linux。这个”Kernel + software + Tools + 可完整安装程序“的东西，我们称之为Linux distributions。</p>
<p>不同的Linux Distributions之间基本上都大同小异，因为他们使用的核心都是由<a href="http://www.kernel.org" target="_blank" rel="noopener">http://www.kernel.org</a>所释出的。并且不同的Linux Distributions之间的开发都参考了一定的标准，如LSB，FHS等标准，而且选用的软件之间的重复性也很高。唯一的差别，可能就是该开发者自家所开发出来的管理工具，以及套件管理的模式吧。</p>
<h1 id="Linux当前应用的角色"><a href="#Linux当前应用的角色" class="headerlink" title="Linux当前应用的角色"></a>Linux当前应用的角色</h1><ol>
<li>企业环境的利用：网络服务器，关键任务的应用（金融数据库），学术机构的高性能运算任务</li>
<li>个人环境的使用：桌面电脑，手持系统，嵌入式系统</li>
<li>云端运用：云程序，端设备</li>
</ol>
<h1 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h1><ol>
<li><p>找出目前Linux核心的最新稳定版与发展中版本的版本号码</p>
<p><em>2020年6月27日</em></p>
<p><em>Linux kernel 最新稳定版本：5.7.6</em></p>
<p><em>Linux kernel 最新发展中版本：5.8-rc2</em></p>
</li>
<li><p>Linux吉祥物企鹅的名字，及最原始的图像文件画面</p>
<p><em>名字叫Tux，图片如下</em></p>
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/b0/NewTux.svg/800px-NewTux.svg.png" alt="Tux" style="zoom: 33%;" />
</li>
<li><p>Android版本与Linux核心版本间的关系</p>
<table>
<thead>
<tr>
<th>Android 版本</th>
<th>Linux核心版本</th>
</tr>
</thead>
<tbody><tr>
<td>1.5 Cupcake</td>
<td>2.6.27</td>
</tr>
<tr>
<td>1.6 Donut</td>
<td>2.6.29</td>
</tr>
<tr>
<td>2.0/1 Eclair</td>
<td>2.6.29</td>
</tr>
<tr>
<td>2.2.x Froyo</td>
<td>2.6.32</td>
</tr>
<tr>
<td>2.3.x Gingerbread</td>
<td>2.6.35</td>
</tr>
<tr>
<td>3.x.x Honeycomb</td>
<td>2.6.36</td>
</tr>
<tr>
<td>4.0.x Ice Cream San</td>
<td>3.0.1</td>
</tr>
</tbody></table>
</li>
<li><p>你在你的主机上面安装了一张网卡，但是开机之后，系统却无法使用，你确定网卡是好的，那么可能的问题出在哪里？该如何解决？</p>
<p><em>因为硬件都没有问题，所以，可能出问题的地方在于系统的核心不支持这种网卡。解决方法是：（1）到网卡的开发商网站 （2）下载支持你主机OS的驱动程序 （3）安装网卡的驱动程序后，就可以正常使用了</em></p>
</li>
<li><p>我在Windows上面玩的游戏，可不可以拿到Linux去玩？</p>
<p><em>不行，因为Windows上的应用程序是根据Windows的核心所开发的，同一个应用程序不能在两个不同的操作系统上工作，除非该软件已经进行了移植。</em></p>
</li>
<li><p>Linux本身仅是一个核心与相关的核心工具而已，不过，他已经可以驱动所有的硬件，所 以，可以算是一个很阳春的操作系统了。经过其他应用程序的开发之后，被整合成为 Linux distribitions。请问众多的distributions之间，有何异同？</p>
<p><em>相同：（1）同样使用<a href="http://www.kernel.org" target="_blank" rel="noopener">http://www.kernel.org</a>所释出的核心； （2）支持同意的标准，如FHS，LSB （3）使用几乎相同的自由软件 （4）几乎相同的操作接口</em></p>
<p><em>不同：使用的Kernel与各软件的版本可能不同；各开发商加入的应用工具不同，使用的套件管理模式不同</em></p>
</li>
<li><p>GNU的全名为何？他主要由那个基金会支持？</p>
<p><em>GNU的全名是GNU is not Unix，该计划是由自由软件基金会（FSF）所支持的。这两者都是由Stallman所发起的</em></p>
</li>
<li><p>什么是POSIX?为何说Linux使用POSIX对于发展有很好的影响？</p>
<p><em>POSIX是一种标准规范，主要针对在Unix上面运行的程序进行规范。若OS符合POSIX，则符合POSIX的程序就可以在该OS上运行。Linux由于支持POSIX，故很多的Unix上的程序可以直接在Linux上运行，因此程序的移植相对简单。</em></p>
</li>
</ol>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>阿飞学Linux——（5）Linux的文件权限与目录配置</title>
    <url>/2020/07/07/%E9%98%BF%E9%A3%9E%E5%AD%A6Linux%E2%80%94%E2%80%94%EF%BC%885%EF%BC%89Linux%E7%9A%84%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E4%B8%8E%E7%9B%AE%E5%BD%95%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>阿飞学Linux——（4）初次使用Centos</title>
    <url>/2020/07/06/%E9%98%BF%E9%A3%9E%E5%AD%A6Linux%E2%80%94%E2%80%94%EF%BC%884%EF%BC%89%E5%88%9D%E6%AC%A1%E4%BD%BF%E7%94%A8Centos/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>阿飞学Linux——（3）安装Centos7.x</title>
    <url>/2020/06/29/%E9%98%BF%E9%A3%9E%E5%AD%A6Linux%E2%80%94%E2%80%94%EF%BC%883%EF%BC%89%E5%AE%89%E8%A3%85Centos7-x/</url>
    <content><![CDATA[<h1 id="安装前的规划"><a href="#安装前的规划" class="headerlink" title="安装前的规划"></a>安装前的规划</h1><ol>
<li><p>该主机的定位：用来练习Linux的相关技术，所以几乎所有的数据都要安装进来。故选择Everything的Distribution版本。</p>
</li>
<li><p>选择的distribution：CentOS 7.x</p>
<div class="note info"><p>阿里云镜像下载网址：&lt; <a href="http://mirrors.aliyun.com/centos/" target="_blank" rel="noopener">http://mirrors.aliyun.com/centos/</a> &gt; </p>
</div>
</li>
<li><p>硬件配置：</p>
<ul>
<li>CPU：intel i5-8250U，<em>这里使用的CPU是我电脑上的</em></li>
<li>内存：1.2G左右</li>
<li>硬盘：一颗40GB左右的VirtI/O芯片组的磁盘</li>
<li>网卡：使用桥接的方式设置了对外网卡，Centos本身就有提供驱动程序，所以可以直接抓到网卡</li>
<li>显卡：入门级显卡即可</li>
<li>I/O设备：不做要求</li>
</ul>
</li>
<li><p>磁盘分区规划</p>
<p>设置成使用GPT分区表来配置磁盘。虽然开机检测程序UEFI可以直接识别GPT分区表，但是开机检测程序BIOS只能读取第一阶段的boot loader。所以，对于GPT格式的磁盘，BIOS boot这个分区还是建议划分的。</p>
<table>
<thead>
<tr>
<th>所需目录/装置</th>
<th>磁盘容量</th>
<th>文件系统</th>
<th>分区格式</th>
</tr>
</thead>
<tbody><tr>
<td>BIOS boot</td>
<td>2MB</td>
<td>系统自订</td>
<td>标准分区</td>
</tr>
<tr>
<td>/boot</td>
<td>1GB</td>
<td>xfs</td>
<td>标准分区</td>
</tr>
<tr>
<td>/</td>
<td>10GB</td>
<td>xfs</td>
<td>LVM 方式</td>
</tr>
<tr>
<td>/home</td>
<td>5GB</td>
<td>xfs</td>
<td>LVM 方式</td>
</tr>
<tr>
<td>swap</td>
<td>1GB</td>
<td>swap</td>
<td>LVM 方式</td>
</tr>
</tbody></table>
<p>如果，你的开机检测程序为UEFI的话，那么还需要划分出一个UEFI支持的分区。</p>
</li>
<li><p>选择软件：含有x接口的服务器软件的方式来安装。</p>
</li>
<li><p>开机检测程序：BIOS</p>
</li>
</ol>
<h1 id="所需工具"><a href="#所需工具" class="headerlink" title="所需工具"></a>所需工具</h1><ol>
<li>虚拟机软件：virtualbox</li>
<li>系统：centos7.x</li>
</ol>
<h1 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h1><h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><ol>
<li>调整开机媒体（BIOS）：使用CD/DVD光盘开机</li>
<li>选择安装模式与开机</li>
<li>选择语系</li>
<li>软件选择</li>
<li>磁盘分区</li>
<li>开机管理程序，网络，时区设置与root密码</li>
<li>安装后的首次设置：包括使用者与防火墙等</li>
</ol>
<h2 id="虚拟机创建与调整开机媒体"><a href="#虚拟机创建与调整开机媒体" class="headerlink" title="虚拟机创建与调整开机媒体"></a>虚拟机创建与调整开机媒体</h2><ol>
<li><p>新建虚拟机</p>
<p><img src="/images/image-20200704163911908.png" alt="image-20200704163911908"></p>
<p><img src="/images/image-20200704164238660.png" alt="image-20200704164238660"></p>
</li>
<li><p>创建虚拟硬盘</p>
<p><img src="/images/image-20200704164403712.png" alt="image-20200704164403712"></p>
</li>
<li><p>至此成功创建一台虚拟机，点击设置，先将镜像文件载入光盘</p>
<p><img src="/images/image-20200704164843754.png" alt="image-20200704164843754"></p>
</li>
<li><p>调整开机媒体顺序</p>
<p><img src="/images/image-20200704165042839.png" alt="image-20200704165042839"></p>
</li>
<li><p>调整网络</p>
<p><img src="/images/image-20200704165424029.png" alt="image-20200704165424029"></p>
</li>
</ol>
<h2 id="选择安装模式与开机"><a href="#选择安装模式与开机" class="headerlink" title="选择安装模式与开机"></a>选择安装模式与开机</h2><p>使用光盘镜像文件开机后，就会出现如下画面：</p>
<p><img src="http://linux.vbird.org/linux_basic/0157installcentos7/centos7_01.jpg" alt="选择安装模式"></p>
<p>图中选项从上而下，分别是：</p>
<ol>
<li>正常安装</li>
<li>测试光盘后再安装系统</li>
<li>进入出错模式，该模式下有更多的选项，分别是<ul>
<li>以图形接口安装系统</li>
<li>救援模式</li>
<li>内存测试</li>
<li>有本机磁盘开机，不由光盘开机</li>
</ul>
</li>
</ol>
<p>由于我们的磁盘容量只有40GB，系统会默认使用MBR分区表，为了改用GPT分区表，我们需要在开机核心参数内添加<code>inst.gpt</code>字段。</p>
<p><img src="http://linux.vbird.org/linux_basic/0157installcentos7/centos7_02.jpg" alt="添加核心参数修改安装程序"></p>
<p>之后，按下回车，系统会开始侦测你的硬件信息。之后就进入到正式的安装流程。安装画面的如下：</p>
<img src="http://linux.vbird.org/linux_basic/0157installcentos7/centos7_05.jpg" alt="安装画面" style="zoom:80%;" />

<p>对于上图中的在地设定，软件等设置很是简单，不多做描写。</p>
<h2 id="磁盘分区与文件系统设置"><a href="#磁盘分区与文件系统设置" class="headerlink" title="磁盘分区与文件系统设置"></a>磁盘分区与文件系统设置</h2><p>点选“系统”项目下的“安装目的地”，之后便会进入如下画面：</p>
<p><img src="http://linux.vbird.org/linux_basic/0157installcentos7/centos7_11.jpg" alt="选择要安装Linux的硬盘，并选择手动分区模式"></p>
<p>如果硬盘中存在旧系统，则在安装Centos之前要清除旧的系统，即删掉旧分区。如果是全新的硬盘就可以省略该步骤。</p>
<p><img src="http://linux.vbird.org/linux_basic/0157installcentos7/centos7_12.jpg" alt="删除旧的分区"></p>
<p>之后开始安装磁盘分区规划对磁盘进行分区。</p>
<p><strong>注意，如果开机检测程序为UEFI，则要划分出一个UEFI支持分区。</strong></p>
<blockquote>
<p>设备类型分为3种：</p>
<ol>
<li>标准分区：类似/dev/sda1之类的分区</li>
<li>LVM：一种可以弹性增加/削减文件系统容量的设备设置。</li>
<li>LVM简单配置：与传统LVM直接分配固定的容量不同，它可以让你在使用多少容量时才分配磁盘多少容量给你。</li>
</ol>
</blockquote>
<blockquote>
<p>文件系统分为以下几种：</p>
<ol>
<li>ext2/ext3/ext4：Linux早期使用的文件系统类型。ext3/ext4多了日志的记录，复原系统比较快。由于磁盘容量越来越大，该文件系统已经较少使用。</li>
<li>swap：磁盘仿真为内存，不需要指定挂载点</li>
<li>BIOS boot：GPT分区表可能会使用到的项目，如果使用MBR分区，就不需要该项目</li>
<li>xfs：CentOS默认的文件系统，对于大容量的磁盘管理非常好，格式化速度快。</li>
<li>vfat：同时被Linux与Windows支持的文件系统类型。</li>
</ol>
</blockquote>
<p>最终完成分区应该如下图所示：</p>
<p><img src="http://linux.vbird.org/linux_basic/0157installcentos7/centos7_24.jpg" alt="完成分区"></p>
<h2 id="核心管理与网络设置"><a href="#核心管理与网络设置" class="headerlink" title="核心管理与网络设置"></a>核心管理与网络设置</h2><p>KDUMP，主要在处理，当Linux系统因为核心问题导致的死机事件时，会将该死机时间的内存数据存储起来的一项功能。可以开启，也可以不开启。</p>
<p>网络设置如下图所示：</p>
<p><img src="http://linux.vbird.org/linux_basic/0157installcentos7/centos7_27.jpg" alt="网络设置"></p>
<p>设置开机自动启动网络的方式如下：</p>
<p><img src="http://linux.vbird.org/linux_basic/0157installcentos7/centos7_28.jpg" alt="开机自启网络"></p>
<p>之后按如下方式配置网卡：</p>
<p><img src="http://linux.vbird.org/linux_basic/0157installcentos7/centos7_29.jpg" alt="手动配置ip"></p>
<p>修改主机名称：</p>
<p><img src="http://linux.vbird.org/linux_basic/0157installcentos7/centos7_30.jpg" alt="修改主机名称"></p>
<p>至此，所有的设置都已完成，开始安装OS。</p>
<p>接下来的开机之后的首次设置较为简单，可以照系统提示完成。</p>
<h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><ol>
<li><p>默认使用MBR分区方式的情况下，在第二颗SATA磁盘中，分区“六个有用”的分区（具有文件系统的），此外，已知有两个primary的分区类型。请问六个分区的文件名？</p>
<p><em>/dev/sdb1 (primary)</em></p>
<p><em>/dev/sdb2 (primary)</em></p>
<p><em>/dev/sdb3 (extended)</em></p>
<p><em>/dev/sdb5,/dev/sdb6,/dev/sdb7,/dev/sdb8 (logical)</em></p>
<p><em>其中逻辑分区的容量总和为/dev/sdb3的容量大小</em></p>
</li>
<li><p>软件磁盘阵列的设备文件名为何？</p>
<p><em>RAID：/dev/md[0-127]</em></p>
</li>
</ol>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>阿飞学Linux——（2）主机规划与磁盘分区</title>
    <url>/2020/06/27/%E9%98%BF%E9%A3%9E%E5%AD%A6Linux%E2%80%94%E2%80%94%EF%BC%882%EF%BC%89%E4%B8%BB%E6%9C%BA%E8%A7%84%E5%88%92%E4%B8%8E%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA/</url>
    <content><![CDATA[<h1 id="Linux与硬件的搭配"><a href="#Linux与硬件的搭配" class="headerlink" title="Linux与硬件的搭配"></a>Linux与硬件的搭配</h1><p>在安装Linux之前，应该先了解下你的Linux主要是想完成哪方面的工作，这样在选购硬件的时候才能知道哪个硬件是最重要的。</p>
<h2 id="选择与Linux搭配的主机配置"><a href="#选择与Linux搭配的主机配置" class="headerlink" title="选择与Linux搭配的主机配置"></a>选择与Linux搭配的主机配置</h2><ul>
<li><p>一般小型主机且不含X Window系统：</p>
<ul>
<li><p>用途：家庭用NAT主机（IP分享器功能）或小型企业之非图形接口小型主机</p>
</li>
<li><p>CPU：五年内出产的产品即可</p>
</li>
<li><p>RAM：521MB~1GB</p>
</li>
<li><p>网卡：一般的以太网卡即可</p>
</li>
<li><p>显卡：只要能够被Linux捕捉到的显卡即可</p>
</li>
<li><p>硬盘：20GB以上即可</p>
<a id="more"></a>
</li>
</ul>
</li>
<li><p>桌上型Linux系统/含X Window：</p>
<ul>
<li>用途：Linux的练习机或工作机</li>
<li>CPU：最好等级高点，如Intel i5，i7以上等级</li>
<li>RAM：大于1GB</li>
<li>网卡：普通的以太网卡即可</li>
<li>显卡：入门级显卡即可</li>
<li>硬盘：越大越好</li>
</ul>
</li>
<li><p>中型以上Linux服务器：</p>
<ul>
<li>用途：中小型企业/学校单位的FTP/mail/www等网络服务主机</li>
<li>CPU：最好等级高点，如Intel i5，i7以上的多核心系统</li>
<li>RAM：大于1GB</li>
<li>网卡：intel或broadcom的品牌较好</li>
<li>显卡：入门级显卡即可</li>
<li>硬盘：越大越好，可能的话使用磁盘阵列</li>
</ul>
</li>
</ul>
<h2 id="各硬件设备在Linux中的文件名"><a href="#各硬件设备在Linux中的文件名" class="headerlink" title="各硬件设备在Linux中的文件名"></a>各硬件设备在Linux中的文件名</h2><p><strong>在Linux中，每个设备都被当成一个文件来对待</strong>，在Linux中，几乎所有的硬件设备文件都在<strong>/dev</strong>这个目录下。常见的硬件设备在Linux中的文件名如下表所示：</p>
<table>
<thead>
<tr>
<th>设备</th>
<th>设备在Linux内的文件名</th>
</tr>
</thead>
<tbody><tr>
<td>SAS/SATA/USB硬盘</td>
<td>/dev/sd[a-p]</td>
</tr>
<tr>
<td>U盘</td>
<td>/dev/sd[a-p] （与SATA相同）</td>
</tr>
<tr>
<td>VirtI/O接口</td>
<td>/dev/vd[a-p] （用于虚拟机内）</td>
</tr>
<tr>
<td>软盘</td>
<td>/dev/fd[0-7]</td>
</tr>
<tr>
<td>打印机</td>
<td>/dev/lp[0-2] （25针打印机）            /dev/usb/lp[0-15] （USB接口）</td>
</tr>
<tr>
<td>鼠标</td>
<td>/dev/input/mouse[0-15] （通用）           /dev/mouse （当前鼠标）</td>
</tr>
<tr>
<td>CDROM/DVDROM</td>
<td>/dev/scd[0-1] （通用）      /dev/cdrom （当前CDROM)）     /dev/sr[0-1]（通用，Centos较常见）</td>
</tr>
<tr>
<td>IDE硬盘</td>
<td>/dev/hd[a-d]（旧式系统才有）</td>
</tr>
</tbody></table>
<h1 id="磁盘分区"><a href="#磁盘分区" class="headerlink" title="磁盘分区"></a>磁盘分区</h1><h2 id="磁盘连接的方式与设备文件名的关系"><a href="#磁盘连接的方式与设备文件名的关系" class="headerlink" title="磁盘连接的方式与设备文件名的关系"></a>磁盘连接的方式与设备文件名的关系</h2><p>目前主流的磁盘接口是SATA接口，如今大部分的Linux distribution已经将ide接口的磁盘文件名也仿真成了SATA接口了。</p>
<p>正常的实体机器上的磁盘文件名大概都是/dev/sd[a-p]，而在虚拟机环境下，磁盘文件名大概就是/dev/vd[a-p]。</p>
<p>如果一个计算机系统内有多个SATA/USB/SAS接口的磁盘，由于他们的设备文件名都是/dev/sd[a-p]，故这些磁盘的设备文件名取决于Linux核心侦测到磁盘的顺序。</p>
<h2 id="MBR和GPT磁盘分区表"><a href="#MBR和GPT磁盘分区表" class="headerlink" title="MBR和GPT磁盘分区表"></a>MBR和GPT磁盘分区表</h2><p>磁盘的第一个扇区记录整颗磁盘的重要信息。早期磁盘第一个扇区里含有的重要信息我们称之为MBR格式。如今随着需求的变化，我们称这些重要信息为GPT。</p>
<ul>
<li><p>MBR</p>
<p>早期的Linux为了相同于Windows的磁盘，因此使用的是支持Windows的MBR的方式来处理开机管理程序和分区表。故磁盘的第一个扇区（512 Byte）存放了两个重要数据</p>
<ul>
<li>主要开机记录区（MBR）：可以安装开机管理程序的地方，有446 Bytes</li>
<li>分区表：记录整颗磁盘分区的状态，有64 Bytes</li>
</ul>
<p>由于分区表只有64 Bytes，故最多只能写入4组分区信息，每组分区信息记录了该分区的开始与结束的柱面号码，这四组分区称之为<strong>主要或延伸分区</strong>，分区的最小单位为通常为柱面。当系统要写入磁盘时，一定会参考磁盘分区表，才能针对某个分区进行数据的处理。</p>
<p>如果我们要将磁盘划分出4个以上的分区，就要借助于延伸分区。<strong>延伸分区的思想是：既然第一个扇区所在的分区表只能记录4组分区信息，那就利用额外的扇区来记录更多的分区信息。</strong>延伸分区本身不能被格式化，而是通过延伸分区所指向的那个区块继续做分区的记录。<strong>延伸分区最多只能有一个。</strong></p>
<img src="http://linux.vbird.org/linux_basic/0130designlinux/partition-2.png" alt="磁盘分区表的作用" style="zoom: 80%;" />

<p>如上图所示，右下方的那个区块又继续分区出5个分区，这5个分区称为<strong>逻辑分区</strong>。逻辑分区的柱面范围就是延伸分区所设置的范围。上图分区的设备文件名如下：</p>
<ul>
<li>p1:/dev/sda1</li>
<li>p2:/dev/sda2</li>
<li>L1:/dev/sda5</li>
<li>L2:/dev/sda6</li>
<li>L3:/dev/sda7</li>
<li>L4:/dev/sda8</li>
<li>L5:/dev/sda9</li>
</ul>
<p><strong>注意：前4个分区号码是保留给主要和延伸分区的。</strong></p>
</li>
<li><p>GPT</p>
<p>为了解决MBR分区表无法记录2.2T以上的磁盘的问题，引入了GPT分区表。</p>
<img src="http://linux.vbird.org/linux_basic/0130designlinux/gpt_partition_1.jpg" alt="GPT分区表结构" style="zoom:80%;" />

<p>GPT使用了34个LBA<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>区块来记录分区信息，并且利用磁盘的最后33个LBA作为分区信息的备份。</p>
<ul>
<li><p>LBA0（MBR相容区块）</p>
<p>该分区放入一个特殊标记，用来表示该磁盘为GPT格式，如果不懂GPT分区表的磁盘管理程序，就不会认识该磁盘。进一步保护了该磁盘。</p>
</li>
<li><p>LBA1（GPT表头记录）</p>
<p>记录了分区表的位置与大小，同时记录了备份用的GPT分区表所放置的位置，同时放置了分区表的校验机制码。</p>
</li>
<li><p>LBA2-33（实际记录分区信息处）</p>
<p>从LBA2区块开始，每个LBA记录了4笔分区记录，故在默认情况下，可以有4*32 = 128笔分区记录。由于每个LBA有512 Bytes，故每笔记录用到了128 Bytes的空间。</p>
</li>
</ul>
<p>不同于MBR，GPT中没有延伸，主要，逻辑分区的概念，每个分区都是独立的，都可以进行格式化。</p>
</li>
</ul>
<h2 id="开机检测程序：BIOS与UEFI"><a href="#开机检测程序：BIOS与UEFI" class="headerlink" title="开机检测程序：BIOS与UEFI"></a>开机检测程序：BIOS与UEFI</h2><ul>
<li><p>BIOS搭配MBR/GPT的开机流程</p>
<ol>
<li>BIOS：开机的时候主动执行BIOS，根据使用者的设定取得能够开机的硬盘</li>
<li>MBR：BIOS读取第一个可开机设备的第一个扇区的开机记录区块，执行开机管理程序</li>
<li>开机管理程序：载入核心文件</li>
<li>核心文件：开始OS的功能</li>
</ol>
<p>对于第2点，如果分区表为GPT格式的话，那么BIOS会从LBA0的MBR相容区块读取第一阶段的开机管理程序，如果开机管理程序能够认识GPT的话，那么使用BIOS同样可以读取到正确的OS核心。</p>
<p><strong>开机管理程序除了可以安装在MBR之外，还可以安装在每个分区的开机扇区，通过特色才能造就“多重开机“。开机管理程序的功能是：提供菜单；载入核心文件；转交其他的loader。</strong></p>
</li>
<li><p>UEFI搭配GPT开机的流程</p>
<p>BIOS不懂GPT，必须要通过GPT提供的MBR相容区块才能够读写该磁盘设备。因此，对比BIOS，UEFI虽然可以直接取得GPT的分区表，不过最好依旧拥有BIOS boot的分区支持。</p>
</li>
</ul>
<h2 id="Linux安装模式下，磁盘分区的选择"><a href="#Linux安装模式下，磁盘分区的选择" class="headerlink" title="Linux安装模式下，磁盘分区的选择"></a>Linux安装模式下，磁盘分区的选择</h2><ul>
<li><p>目录树结构</p>
<p>所谓的目录树结构就是以根目录/为主，然后向下呈现分枝状的目录结构的一种文件架构。</p>
<p><img src="http://linux.vbird.org/linux_basic/0130designlinux/dirtree.gif" alt="目录树结构"></p>
<p>上图中，长方形为目录，波浪形为文件。可见，所有的文件都是由根目录（/）发起，而次目录下还能够有其他的数据存在。</p>
</li>
<li><p>文件系统与目录树的关系（挂载）</p>
<p>所谓的”挂载“就是利用一个目录当成进入点，将磁盘分区的数据放置在该目录下。简单来说，就是进入该目录就可以读取该分区的意思。这个进入点的目录称之为<strong>”挂载点“</strong>。</p>
<img src="http://linux.vbird.org/linux_basic/0130designlinux/dir_3.png" alt="目录树与分区间的关系" style="zoom:80%;" />

</li>
</ul>
<h1 id="主机硬盘的规划"><a href="#主机硬盘的规划" class="headerlink" title="主机硬盘的规划"></a>主机硬盘的规划</h1><ul>
<li>最简单的分区方法：仅分区出根目录（/）与内存交换空间（swap）即可。然后，预留一些剩余的磁盘供后续的联系使用。</li>
<li>较麻烦的分区方法：先分析该主机的未来用途，然后根据用途去分析需要较大容量的目录，以及读写较为频繁的目录，将这些重要的目录独立出来而不与根目录（/）放在一起。使得当这些读写较为频繁的磁盘分区出现问题时，不会影响到根目录的系统数据。在默认的Centos环境中，下面的目录是比较符合容量大且读写频繁的目录：<ul>
<li>/boot</li>
<li>/</li>
<li>/home</li>
<li>/var</li>
<li>Swap</li>
</ul>
</li>
</ul>
<h1 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h1><ol>
<li><p>一部计算机主机是否只要CPU够快，整体速度就会提高？</p>
<p><em>错！一部计算机系统的速度与整体计算机系统的运行有关，每个元件都会影响计算机的速度。包括了内存，CPU，AGP与显卡速度，硬盘的速度以及其他相关的I/O接口等。</em></p>
</li>
<li><p>一部好的主机在安装之前，最好先进行规划，哪些是必须要主要的Linux主机规划事项？</p>
<p><em>Linux主机在安装之前，一定要规划Linux主机的定位与角色！因此，Linux的主机是否开放网络服务？未来是否会进行大量的运算？该主机是否需要提供很大的硬盘容量来服务客户端的使用？这些都是要经过考虑的。</em></p>
</li>
<li><p>请写出下列设备，在Linux的设备文件名：SATA硬盘；CDROM；打印机；软盘；</p>
<p><em>SATA硬盘：/dev/sd[a-p]</em></p>
<p><em>CDROM：/dev/cdrom，/dev/sr[0-1]，/dev/scd[0-1]</em></p>
<p><em>打印机：/dev/lp[0-2]</em></p>
<p><em>软盘：/dev/fd[0-1]</em></p>
</li>
<li><p>目前在PC上面常见的硬盘与主板的连接接口有那两个？</p>
<p><em>有内置的SATA接口与外接式的USB接口</em></p>
</li>
</ol>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">逻辑区块地址，GPT将磁盘所有区块以LBA（默认为512 Bytes）来规划，第一个LBA称为LBA0</span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>阿飞学Markdown</title>
    <url>/2020/06/13/%E9%98%BF%E9%A3%9E%E5%AD%A6Markdown/</url>
    <content><![CDATA[<h1 id="Markdown是什么"><a href="#Markdown是什么" class="headerlink" title="Markdown是什么"></a>Markdown是什么</h1><p>Markdown就是由一些简单的符号（如***** /-&gt; [] （）#）组成的用于排版的标记语言，其最重要的特点就是可读性强。</p>
<p>Markdown的语法分为，基础语法和扩展语法。在众多的扩展语法中GFM是最流行的，它扩展了包括表格，任务列表，删除线，围栏代码，Emoji等在内的语法。</p>
<a id="more"></a>

<h2 id="Markdown的工作流程"><a href="#Markdown的工作流程" class="headerlink" title="Markdown的工作流程"></a>Markdown的工作流程</h2><p><img src="/images/Image00007.jpg" alt="Markdown工作流程"></p>
<h2 id="Markdown的编辑器"><a href="#Markdown的编辑器" class="headerlink" title="Markdown的编辑器"></a>Markdown的编辑器</h2><p>这里推荐两个流行的Markdown编辑器，分别是Typora和vs Code.下载地址如下:</p>
<p>typora:  <a href="https://typora.io/" target="_blank" rel="noopener">https://typora.io/</a></p>
<p>vs Code: <a href="https://code.visualstudio.com/download" target="_blank" rel="noopener">https://code.visualstudio.com/download</a></p>
<h1 id="Markdown的基础语法"><a href="#Markdown的基础语法" class="headerlink" title="Markdown的基础语法"></a>Markdown的基础语法</h1><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><ol>
<li>标题<ul>
<li>语法：<code># + 空格 + 标题内容</code></li>
<li>说明：#的个数表示了标题的等级，建议在#后加一个空格</li>
</ul>
</li>
<li>粗体<ul>
<li>语法：<code>**+加粗内容+**</code></li>
<li>说明：在*的后面不带有空格</li>
</ul>
</li>
<li>斜体<ul>
<li>语法：<code>*+斜体内容+*</code></li>
<li>说明：在*的后面不带有空格</li>
</ul>
</li>
</ol>
<h2 id="段落与换行"><a href="#段落与换行" class="headerlink" title="段落与换行"></a>段落与换行</h2><ol>
<li><p>列表</p>
<ul>
<li>有序列表<ul>
<li>语法：<code>数字序号 + . + 空格 + 列表内容</code></li>
</ul>
</li>
<li>无须列表<ul>
<li>语法：<code>* + 空格 + 列表内容</code></li>
</ul>
</li>
<li>说明：列表可相互嵌套，有序列表和无序列表之间也可以相互嵌套。（<em>建议在列表前/后都空1行</em>）</li>
</ul>
</li>
<li><p>分割线</p>
<ul>
<li>语法：<code>---</code></li>
<li>说明：至少要有三个以上的 - 来标记</li>
</ul>
</li>
<li><p>图片</p>
<ul>
<li>语法：<code>![图片替代文字](图片地址)</code></li>
<li>说明：图片地址可以是本地图片(<a href="[http://www.theoak.online/2020/03/13/hexo%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%E4%B8%8D%E6%98%BE%E7%A4%BA/](http://www.theoak.online/2020/03/13/hexo本地图片不显示/)">关于hexo引用本地图片无法显示</a>)的路径或是网络图片的地址；支持绝对路径和相对路径两种方式.</li>
</ul>
</li>
<li><p>链接</p>
<ul>
<li><p>文字链接</p>
<ul>
<li>语法：<code>[链接文字]（链接地址）</code></li>
<li>说明：在扩展语法GFM中，可以只输入url，也能被自动识别为网络链接</li>
</ul>
</li>
<li><p>引用链接</p>
<ul>
<li><p>语法：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">链接文字</span>][<span class="symbol">链接标记</span>]</span><br><span class="line">[<span class="symbol">链接标记</span>]:<span class="link">链接地址</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>说明：链接地址为网络地址时要以http开头，否则会被识别为本地地址</p>
</li>
</ul>
</li>
<li><p>网址链接</p>
<ul>
<li>语法：<code>&lt;url&gt;</code></li>
</ul>
</li>
</ul>
</li>
<li><p>代码块</p>
<ul>
<li><p>行内代码</p>
</li>
<li><p>语法：&#39;代码&#39;</p>
</li>
<li><p>代码块</p>
<ul>
<li><p>语法：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">···语言</span><br><span class="line">代码</span><br><span class="line">···</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>引用</p>
<ul>
<li>语法：<code>&gt;+应用内容</code></li>
<li>说明：引用可以嵌套；建议在&gt;之后加一个空格；不要在引用中添加空行</li>
</ul>
</li>
</ol>
<h1 id="Markdown的扩展语法"><a href="#Markdown的扩展语法" class="headerlink" title="Markdown的扩展语法"></a>Markdown的扩展语法</h1><ol>
<li><p>删除线</p>
<ul>
<li>语法：<code>~~被删除的文字~~</code></li>
</ul>
</li>
<li><p>Emoji表情</p>
<ul>
<li>语法：<code>:表情代码:</code></li>
</ul>
</li>
<li><p>表格</p>
<ul>
<li><p>语法：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">|表头1|表头2|表头3|</span><br><span class="line">|----|----|----|</span><br><span class="line">|内容1|内容2|内容3|</span><br></pre></td></tr></table></figure>
</li>
<li><p>说明：块级元素不能插入表格中</p>
</li>
</ul>
</li>
<li><p>任务列表</p>
<ul>
<li>语法：<code>- + 空格 + [ + 空格/x + ] 任务内容</code></li>
</ul>
</li>
<li><p>锚点（书签）</p>
<ul>
<li>语法：<code>[锚点描述](#锚点名)</code> </li>
</ul>
</li>
<li><p>上标和下标</p>
<ul>
<li>语法：<code>~下标内容~</code>      <code>^上标内容^</code></li>
</ul>
</li>
<li><p>注释</p>
<ul>
<li>语法：<code>&lt;!--注释内容--&gt;</code></li>
</ul>
</li>
<li><p>脚注</p>
<ul>
<li><p>语法：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">欲添加脚注的内容[^脚注]</span><br><span class="line">[<span class="symbol">^脚注</span>]:<span class="link">这段文字是对脚注的描述</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
</search>
