<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2020/06/11/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<a id="more"></a>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      <categories>
        <category>test</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo折腾记（1）——安装与使用NexT主题</title>
    <url>/2020/06/30/Hexo%E6%8A%98%E8%85%BE%E8%AE%B0%EF%BC%881%EF%BC%89%E2%80%94%E2%80%94%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8NexT%E4%B8%BB%E9%A2%98/</url>
    <content><![CDATA[<h1 id="安装NexT"><a href="#安装NexT" class="headerlink" title="安装NexT"></a>安装NexT</h1><p>Next的安装分为三步骤：</p>
<ol>
<li><p>下载主题</p>
<p>进入Hexo站点目录下，使用<code>git clone</code>下载最新的NexT主题。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$cd</span> your-hexo-site</span><br><span class="line"><span class="variable">$git</span> <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>

<div class="note info"><p>当要更新NexT主题的时候，可以进入theme/next文件夹下，使用<code>git pull</code>，进行更新合并 </p></div>
</li>
<li><p>启用主题</p>
<p>打开<strong>站点配置文件_config.yml</strong>，找到theme字段，并将其值改为<code>next</code>。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>验证主题是否正确启用</p>
<p>启动Hexo本地服务器，并开启调试模式，当出现如下命令提示时，说明启动成功：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">INFO  Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure>

<p>此时，可以用浏览器访问<code>http://localhost:4000</code>，检查Next是否配置成功，当出现如下画面时，说明NexT成功启用。</p>
<p><img src="https://theme-next.iissnan.com/uploads/five-minutes-setup/validation-default-scheme-mac.png" alt="NexT成功启用"></p>
</li>
</ol>
<h1 id="外观切换"><a href="#外观切换" class="headerlink" title="外观切换"></a>外观切换</h1><p>NexT提供了4种不同的外观进行切换，分别为Muse，Mist，Pisces，Gemini。</p>
<p>首先进入<strong>主题配置文件_config.yml</strong>，搜索scheme关键字。按个人喜好选择合适的外观。如下所示，设置外观为Pisces。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Scheme Settings</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Schemes</span></span><br><span class="line"><span class="comment">#scheme: Muse</span></span><br><span class="line"><span class="comment">#scheme: Mist</span></span><br><span class="line"><span class="attr">scheme:</span> <span class="string">Pisces</span></span><br><span class="line"><span class="comment">#scheme: Gemini</span></span><br></pre></td></tr></table></figure>

<h1 id="设置菜单"><a href="#设置菜单" class="headerlink" title="设置菜单"></a>设置菜单</h1><p>NexT默认只启用了home和archives两个菜单项。我们可以手动开启更多的菜单项。</p>
<ol>
<li><p>首先，进入<strong>主题配置文件_config.yml</strong>，搜寻menu关键字。按需要进行菜单设置，将需要使用的菜单项取消注释。如下所示，分别启用了菜单项：home，about，tags，categories，archives。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Menu Settings</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/||</span> <span class="string">home</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">/about/||</span> <span class="string">user</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/||</span> <span class="string">tags</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/||</span> <span class="string">th</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/||</span> <span class="string">archive</span></span><br><span class="line">  <span class="comment">#schedule: /schedule/ || calendar</span></span><br><span class="line">  <span class="comment">#sitemap: /sitemap.xml || sitemap</span></span><br><span class="line">  <span class="comment">#commonweal: /404/ || heartbeat</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>菜单项开启后，点击菜单项无法进入到对应的页面，我们需要为菜单项建立对应的页面。</p>
<ul>
<li><p>建立tags页面</p>
<p>首先，进入Hexo站点目录，新建一个页面，命名为tags：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$cd</span> your-hexo-site</span><br><span class="line"><span class="variable">$hexo</span> new page tags</span><br></pre></td></tr></table></figure>

<p>其次，编辑新建的页面，将页面类型设置为tags，主题将为该页面显示标签云。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">date: 2020-06-30 11:17:38</span><br><span class="line">type: "tags"</span><br><span class="line">comments: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
</li>
<li><p>建立categories页面</p>
<p>首先，进入Hexo站点目录，新建一个页面，命名为categories：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$cd</span> your-hexo-site</span><br><span class="line"><span class="variable">$hexo</span> new page categories</span><br></pre></td></tr></table></figure>

<p>其次，编辑新建的页面，将页面类型设置为tags，主题将为该页面显示标签云。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">date: 2020-06-30 11:17:38</span><br><span class="line">type: "categories"</span><br><span class="line">comments: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>阿飞学Linux——（0）计算机概论</title>
    <url>/2020/06/25/%E9%98%BF%E9%A3%9E%E5%AD%A6Linux%E2%80%94%E2%80%94%EF%BC%880%EF%BC%89%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A6%82%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="什么是电脑"><a href="#什么是电脑" class="headerlink" title="什么是电脑"></a>什么是电脑</h1><p>电脑是指接受用户输入指令与数据，经由cpu等数学与逻辑单元运算处理后，以产生或储存成有用的信息。</p>
<h2 id="计算机硬件的五大单元"><a href="#计算机硬件的五大单元" class="headerlink" title="计算机硬件的五大单元"></a>计算机硬件的五大单元</h2><p>计算机是由五个单元组成的，包括<strong>输入单元，输出单元，cpu内部的控制单元，算数逻辑单元与内存</strong>五个部分。</p>
<p>cpu内部的控制单元负责协调周边元件与各单元间的工作，而算术逻辑单元负责程序运算与逻辑判断。</p>
<p>故计算机的工作流程是，用户利用输入单元输入数据，之后数据流入内存，cpu从内存读取数据进行运算后，将结果写回内存后送给输出单元显示。</p>
<a id="more"></a>

<p><img src="http://linux.vbird.org/linux_basic/0105computers/computer02.gif" alt="电脑的五大单元"></p>
<h2 id="CPU的架构"><a href="#CPU的架构" class="headerlink" title="CPU的架构"></a>CPU的架构</h2><p>cpu的架构分为两种，分别是精简指令集（RISC）与复杂指令集（CISC）。</p>
<p>精简指令集较为精简，每个指令的执行时间较短，完成的动作单纯，执行性能较佳；而复杂指令集包含较多的指令，指令的执行较复杂，花费时间较长。</p>
<h2 id="电脑上常用的计算单位"><a href="#电脑上常用的计算单位" class="headerlink" title="电脑上常用的计算单位"></a>电脑上常用的计算单位</h2><ol>
<li><p>容量单位</p>
<p>电脑在存取数据时是以Byte为单位的，而1 Byte = 8 bits。</p>
<p>常见的单位转换如下</p>
<table>
<thead>
<tr>
<th>进位制</th>
<th>Kilo</th>
<th>Mega</th>
<th>Giga</th>
<th>Tera</th>
</tr>
</thead>
<tbody><tr>
<td>二进制</td>
<td>1024B</td>
<td>1024K</td>
<td>1024M</td>
<td>1024G</td>
</tr>
</tbody></table>
</li>
<li><p>速度单位</p>
<p>CPU的运算速度常使用MHz或GHz之类的单位。而网络传输方面，常使用的单位为Mbps即Mbits per second。</p>
</li>
</ol>
<h1 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h1><h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><p>不同的CPU型号具有不同的脚位，因此能够搭配的主板芯片组也不同。</p>
<p>CPU内部含有微指令集，不同的微指令集使CPU具有不同的工作效率。除此之外，CPU性能的比较还与CPU的频率有很大的关系。</p>
<ul>
<li><p>CPU的工作频率：外频与倍频</p>
<p>早期的CPU架构通过北桥来链接系统最重要的CPU，内存与显卡设备。由于所有的设备都通过北桥来链接，故每个设备的工作频率要相同。但是CPU的运算速度远高于其他设备，故为了迎合其他设备的速度，需要在CPU内部进行再加速，于是就有了外频与倍频。外频*倍频，所得到的就是CPU的真实频率速度。不过，由于速度被北桥所卡死了，故目前已经取消了北桥，取而代之的是，将内存控制器整合到CPU内部，使得CPU可以直接与内存等设备分别进行沟通。</p>
<p><em>倍频是固定好的，故进行超频时，修改的是外频。</em></p>
</li>
<li><p>32位与64位的CPU</p>
<p>CPU每次能够从内存中读取数据进行处理的数据量称为字组大小，字组大小依据CPU的设计有32位和64位。</p>
</li>
</ul>
<h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>CPU所使用的数据都是来自于内存。个人电脑的内存主要为动态随机存取内存DRAM，是一种挥发性内存。DRAM又可以分为SDRAM和DDR SDRAM两种。DDR是所谓的双倍数据传送速度，它可以在一次工作周期中进行两次数据传送。</p>
<ul>
<li><p>多通道设计</p>
<p>传统的总线宽度一般为64位，为了加大该宽度，因此芯片组厂商将两个内存汇整在一起，如果一支内存是64位，则两支内存可以达到128位，这就是双通道设计。</p>
</li>
<li><p>DRAM与SRAM</p>
<p>由于CPU与内存之间的通信还得要经过内存控制器，故如果将部分数据放在CPU中的话，可以提高性能。由此引入了高速缓存，但是DRAM无法达到所要求的频率速度，故需要使用SRAM（静态随机存取内存）。</p>
<p><img src="http://linux.vbird.org/linux_basic/0105computers/computer07.gif" alt="高速缓存作用"></p>
</li>
<li><p>ROM</p>
<p>ROM也叫只读存储器，是一种非挥发性的内存。很多的固件，通常就是写入ROM中</p>
</li>
</ul>
<h2 id="显卡"><a href="#显卡" class="headerlink" title="显卡"></a>显卡</h2><p>显卡对于图像影像的显示扮演了关键的角色。</p>
<p>显卡上会有一个内存的容量，称为显存，它的容量影响到屏幕分辨率于色彩深度。而随着3D游戏的流行，显卡运算能力愈发重要，因此显卡会内嵌一个3D加速芯片，这就是所谓的GPU。目前主流的显卡规格是PCI-e，它拥有更快的传输带宽。</p>
<table>
<thead>
<tr>
<th>规格</th>
<th>1x带宽</th>
<th>16x带宽</th>
</tr>
</thead>
<tbody><tr>
<td>PCIe 1.0</td>
<td>250MB/s</td>
<td>4GB/s</td>
</tr>
<tr>
<td>PCIe 2.0</td>
<td>500MB/s</td>
<td>8GB/s</td>
</tr>
<tr>
<td>PCIe 3.0</td>
<td>~1GB/s</td>
<td>~16GB/s</td>
</tr>
<tr>
<td>PCIe 4.0</td>
<td>~2GB/s</td>
<td>~32GB/s</td>
</tr>
</tbody></table>
<h2 id="硬盘"><a href="#硬盘" class="headerlink" title="硬盘"></a>硬盘</h2><p>硬盘在运行时，主轴马达让盘片转动，然后机械手臂可伸展让磁头在盘片上进行读写。一个硬盘内会有多个盘片。盘片上的数据如下图所示：</p>
<p><img src="http://linux.vbird.org/linux_basic/0105computers/Disktructure.jpg" alt="盘片上的数据格式"></p>
<p>盘片上的每个小区块，称之为<strong>扇区</strong>。同一个同心圆的扇区组合成的圆称为<strong>磁道</strong>。而所有盘片上面的同一个磁道组合成了<strong>柱面</strong>。</p>
<ul>
<li><p>传输接口</p>
<ul>
<li><p>SATA接口</p>
<p>目前SATA已经发展到了第三代，SATA 3.0的理论接口速度可以达到600 MByte/s。</p>
</li>
<li><p>USB接口</p>
<p>如果磁盘是外接式的接口，那么跟主板链接的很可能就是USB接口。目前USB 3.1的理论传输速度可以达到1000 MByte/s，但是实际上并不可能达到。</p>
</li>
</ul>
</li>
<li><p>固态硬盘SSD</p>
<p>传统的硬盘读写数据延迟较高，因此产生了固态硬盘，它没有寻道时间和旋转延迟，可以通过内存直接读写，大大提高了传输效率。</p>
</li>
</ul>
<h2 id="扩展卡与接口"><a href="#扩展卡与接口" class="headerlink" title="扩展卡与接口"></a>扩展卡与接口</h2><p>多信道的卡，例如x8的卡可以安装在少信道的插槽上，如x4的插槽。只是如此这般的话，这张卡的极限性能会下降。</p>
<h2 id="主板"><a href="#主板" class="headerlink" title="主板"></a>主板</h2><ul>
<li><p>发挥扩展卡性能需要考虑插槽的位置</p>
<p>如果我们将卡安装在跟CPU直接相连的那几个插槽上，可以得到最佳性能，但是如果安装在与南桥相连接的插槽上，那么扩展卡的数据要先进入南桥争抢带宽，之后再通过DMI 2.0将数据传给CPU。DMI 2.0的传输速度远远低于PCIe 2.0x8的传输速度，由此导致了性能瓶颈。</p>
</li>
<li><p>CMOS与BIOS</p>
<p>CMOS是嵌入在主板上面的存储器，主要功能为记录主板上面的重要参数，包括系统时间，CPU电压与频率等。</p>
<p>BIOS是主板上的固件，在开机时计算机主动执行的第一个程序，负责载入CMOS中的参数，并调用储存设备中的开机程序。</p>
</li>
<li><p>连接周边设备的接口</p>
<p><img src="http://linux.vbird.org/linux_basic/0105computers/connect02.jpg" alt="链接周边设备接口"></p>
<ul>
<li>USB接口：USB 3.0为蓝色的插槽颜色。</li>
</ul>
</li>
</ul>
<h1 id="数据表示方式"><a href="#数据表示方式" class="headerlink" title="数据表示方式"></a>数据表示方式</h1><h2 id="数字系统"><a href="#数字系统" class="headerlink" title="数字系统"></a>数字系统</h2><p>二进制是计算机的基础。</p>
<p>二进制与十进制的转换如下：</p>
<p>1101 = 1 * 2^3^ + 1 * 2^2^ + 0 * 2^1^ + 1 * 2^0^</p>
<p>十进制转二进制如下：</p>
<p><img src="http://linux.vbird.org/linux_basic/0105computers/number_01.gif" alt="十进制转二进制方法"></p>
<h2 id="文字编码系统"><a href="#文字编码系统" class="headerlink" title="文字编码系统"></a>文字编码系统</h2><p>计算机上文字的存储采用的文字编码系统的方式来实现的。具体实现如下图所示：</p>
<p><img src="http://linux.vbird.org/linux_basic/0105computers/word_01.gif" alt="文字编码系统"></p>
<p>常用的英文编码表是ASCII编码，在该编码中，每个符号占1 Bytes的记录，故有2^8^ = 256种变化。</p>
<h1 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h1><h2 id="机器程序与编译程序"><a href="#机器程序与编译程序" class="headerlink" title="机器程序与编译程序"></a>机器程序与编译程序</h2><p>对于人类而言直接编写机器程序是不现实的，因此产生了高级程序语言。利用高级程序语言编写代码后，交与编译器进行编译后得到机器码，这样简化了写代码的工作。</p>
<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><p>OS其实也是一组程序，这组程序的重点在于管理电脑的所有活动以及驱动系统中的所有硬件。但是，要命令OS驱动硬件工作，必须有应用程序的帮助。</p>
<ul>
<li><p>OS核心</p>
<p>OS核心负责管控硬件以及提供合理的电脑系统资源分配。核心程序是参考硬件编写的，故同一个OS程序不能够在不同的硬件架构下运行。当硬件发生变动时，核心程序也要做出调整。并且核心程序是受保护的，不能被用户直接调用。因此，OS提供了系统调用接口，使得用户可以通过该接口调用核心功能，从而编写应用程序来完成复杂的工作。</p>
<p><img src="http://linux.vbird.org/linux_basic/0105computers/os_01.gif" alt="OS的角色"></p>
</li>
<li><p>驱动程序</p>
<p><img src="http://linux.vbird.org/linux_basic/0105computers/computer_driver.png" alt="驱动程序与OS的关系"></p>
<p>OS必须能够驱动硬件，如此应用程序才能够使用该硬件功能。通常OS会提供开发接口，让开发商制作他们的驱动程序。要使用新硬件功能，必须要安装合适的驱动程序。</p>
</li>
</ul>
<h2 id="应用程序"><a href="#应用程序" class="headerlink" title="应用程序"></a>应用程序</h2><p>应用程序时参考OS提供的开发接口所开发出来的软件，这些软件可以让用户操作，从而达到某些电脑的功能利用。 </p>
<h1 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h1><ol>
<li><p>全世界目前跑的最快的计算机（2020年6月23日）</p>
<ul>
<li>名称：富岳</li>
<li>系统名称：Red Hat </li>
<li>所在位置：日本</li>
<li>使用的CPU型号与规格：64位处理器A64FX，采用ARM架构</li>
<li>总共使用的CPU数量：15W</li>
</ul>
</li>
<li><p>Intel i7 4790 CPU的信息</p>
<ul>
<li>与南桥沟通的DMI带宽：5 GT/s</li>
<li>第二层高速缓存容量：8 MB</li>
<li>最大PCIe信道数量：16</li>
<li>主板上面PCIe插槽的数量限制：1x16,2x8,1x8+2x4</li>
</ul>
</li>
<li><p>Intel SSD 520相关信息</p>
<ul>
<li>连接接口：SATA 3.0 6 Gb/s</li>
<li>最大读写速度：读——550 MB/s，写——520 MB/s</li>
<li>最大随机读写数据：读——25000 IOPS，写——40000 IOPS</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo折腾记（2）——NexT设置背景图片</title>
    <url>/2020/06/30/Hexo%E6%8A%98%E8%85%BE%E8%AE%B0%EF%BC%882%EF%BC%89%E2%80%94%E2%80%94NexT%E8%AE%BE%E7%BD%AE%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<h1 id="设置背景图片"><a href="#设置背景图片" class="headerlink" title="设置背景图片"></a>设置背景图片</h1><p>NexT主题本身是没有背景图片的，设置一个个性化的背景图片，会让blog变得更加美观。</p>
<p>可以通过以下的方式为NexT主题设置背景图片。</p>
<ol>
<li><p>将想要的背景图片放入<code>themes/next/source/images</code>。</p>
</li>
<li><p>打开<code>themes/next/source/css/ _custom/custom.styl</code>文件，该文件是NexT提供给用户进行个性化定制的文件。在该文件中添加如下代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>:<span class="built_in">url</span>(/images/yourbackground.jpg);</span><br><span class="line">    background-repeat: no-repeat; //不重复</span><br><span class="line">    <span class="selector-tag">background-attachment</span><span class="selector-pseudo">:fixed</span>; </span><br><span class="line">    background-size: cover;      //填充</span><br><span class="line">    <span class="selector-tag">background-position</span><span class="selector-pseudo">:50</span>% 50%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>background:url</code> 为图片路径，也可以直接使用链接。</li>
<li><code>background-repeat</code>：若果背景图片不能全屏，那么是否平铺显示，充满屏幕</li>
<li><code>background-attachment</code>：背景是否随着网页上下滚动而滚动，fixed 为固定</li>
<li><code>background-size</code>：图片展示大小，这里设置 100%，100% 的意义为：如果背景图片不能全屏，那么是否通过拉伸的方式将背景强制拉伸至全屏显示。</li>
</ul>
</li>
<li><p>设置背景后，可以考虑将博客文件降低透明度，这样可以更好地表现背景图片。</p>
<p>在<code>themes/next/source/css/_custom/custom.styl</code> 中添加以下内容：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">//博客内容透明化</span><br><span class="line">//文章内容的透明度设置</span><br><span class="line"><span class="selector-class">.content-wrap</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.9</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//侧边框的透明度设置</span><br><span class="line"><span class="selector-class">.sidebar</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.9</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//菜单栏的透明度设置</span><br><span class="line"><span class="selector-class">.header-inner</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,<span class="number">0.9</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//搜索框（local-search）的透明度设置</span><br><span class="line"><span class="selector-class">.popup</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.9</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>阿飞学Linux——（1）初识Linux</title>
    <url>/2020/06/27/%E9%98%BF%E9%A3%9E%E5%AD%A6Linux%E2%80%94%E2%80%94%EF%BC%881%EF%BC%89%E5%88%9D%E8%AF%86Linux/</url>
    <content><![CDATA[<h1 id="初识Linux"><a href="#初识Linux" class="headerlink" title="初识Linux"></a>初识Linux</h1><h2 id="什么是Linux"><a href="#什么是Linux" class="headerlink" title="什么是Linux"></a>什么是Linux</h2><p>Linux是一种OS，于1991年，由芬兰的Linus Torvalds开发而成，具有“可移植性”和良好的稳定性。</p>
<h2 id="GNU计划，自由软件与开放源代码"><a href="#GNU计划，自由软件与开放源代码" class="headerlink" title="GNU计划，自由软件与开放源代码"></a>GNU计划，自由软件与开放源代码</h2><p>将源代码连同软件程序释出的举动，在GNU计划的范畴之内被称为自由软件运动。同时为了防止自由软件被他人做成专利软件，Stallman将所有GNU与FSF开发出来的软件挂上了GPL的版权宣告——自由软件是一种自由的权力，并非是“价格”。</p>
<a id="more"></a>

<p>自由软件具有如下几个特点：取得软件与源代码，复制，修改，再发行，回馈，不能修改授权，不能单纯贩卖。</p>
<p>开放源代码（Open Source，简称开源软件）是指具有如下特点的软件：公布源代码且用户具有修改权；任意的再散布；允许修改或衍生作品；不可限制某些个人或团体的使用权；不可限制某些领域的应用；不可具有排他条款；</p>
<p>可见，GPL自由软件也是开源软件的一种。</p>
<h1 id="Linux的发展"><a href="#Linux的发展" class="headerlink" title="Linux的发展"></a>Linux的发展</h1><p>由于Minix无法满足使用者的功能需求，故Linus Torvalds参考Minix，编写了一个可以运行于386机器上的OS核心，即Linux。Linux完全相容于Unix，在Unix上运行的程序或软件，也可以在Linux上运行。Linus鼓励更多的开发人员共同参与到Linux的开发中。</p>
<p>为了应对程序码加入的状况，于是Linux便逐渐发展成具有模块的功能！亦即是将某些功能独立出于核心外，在需要的时候才载入到核心中。如此一来，如果有新的硬件驱动程序或者其他协定的程序码进来时，就可以模块化，大大的增加了Linux核心的可维护能力！</p>
<h2 id="Linux的核心版本"><a href="#Linux的核心版本" class="headerlink" title="Linux的核心版本"></a>Linux的核心版本</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">3.10.0 - 123.e17.x86_64</span><br><span class="line">主版本.次版本.释出版本 - 修改版本</span><br></pre></td></tr></table></figure>

<p>在2.6.x版本之前，Torvalds将核心的发展趋势分为两股</p>
<ul>
<li>主，次版本为奇数：发展中版本</li>
<li>主，次版本为偶数：稳定版本</li>
</ul>
<p>不过在3.0版本推出之后，这种以奇数，偶数分类的编号格式就失效了。转而以主线版本和长期维护版本分类。从3.0版本开始，核心主要依据主线版本来开发，开发完毕后往下一个主线版本进行，如3.10就是在3.9的基础下开发出来的新的主线版本。而旧的主线版本有两种处理方式，一是结束开发，而是转为长期维护版本。</p>
<p>要判断Linux核心是否为长期支持的版本，可以使用<code>uname -r</code> 来查阅核心版本，之后对照链接<a href="https://www.kernel.org/releases.html" target="_blank" rel="noopener">https://www.kernel.org/releases.html</a>的数据来分析。<strong>要注意，Linux distributions的版本号不等同于Linux kernel的版本。</strong></p>
<h2 id="Linux-distributions"><a href="#Linux-distributions" class="headerlink" title="Linux distributions"></a>Linux distributions</h2><p>为了帮助一般的用户使用Linux，许多商业公司或非盈利团体，就将Linux核心与可运行的软件整合起来，加上自己具有创意的工具程序，该工具程序可以让使用者以光盘/dvd或者通过网络直接安装/管理Linux。这个”Kernel + software + Tools + 可完整安装程序“的东西，我们称之为Linux distributions。</p>
<p>不同的Linux Distributions之间基本上都大同小异，因为他们使用的核心都是由<a href="http://www.kernel.org" target="_blank" rel="noopener">http://www.kernel.org</a>所释出的。并且不同的Linux Distributions之间的开发都参考了一定的标准，如LSB，FHS等标准，而且选用的软件之间的重复性也很高。唯一的差别，可能就是该开发者自家所开发出来的管理工具，以及套件管理的模式吧。</p>
<h1 id="Linux当前应用的角色"><a href="#Linux当前应用的角色" class="headerlink" title="Linux当前应用的角色"></a>Linux当前应用的角色</h1><ol>
<li>企业环境的利用：网络服务器，关键任务的应用（金融数据库），学术机构的高性能运算任务</li>
<li>个人环境的使用：桌面电脑，手持系统，嵌入式系统</li>
<li>云端运用：云程序，端设备</li>
</ol>
<h1 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h1><ol>
<li><p>找出目前Linux核心的最新稳定版与发展中版本的版本号码</p>
<p><em>2020年6月27日</em></p>
<p><em>Linux kernel 最新稳定版本：5.7.6</em></p>
<p><em>Linux kernel 最新发展中版本：5.8-rc2</em></p>
</li>
<li><p>Linux吉祥物企鹅的名字，及最原始的图像文件画面</p>
<p><em>名字叫Tux，图片如下</em></p>
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/b0/NewTux.svg/800px-NewTux.svg.png" alt="Tux" style="zoom: 33%;" />
</li>
<li><p>Android版本与Linux核心版本间的关系</p>
<table>
<thead>
<tr>
<th>Android 版本</th>
<th>Linux核心版本</th>
</tr>
</thead>
<tbody><tr>
<td>1.5 Cupcake</td>
<td>2.6.27</td>
</tr>
<tr>
<td>1.6 Donut</td>
<td>2.6.29</td>
</tr>
<tr>
<td>2.0/1 Eclair</td>
<td>2.6.29</td>
</tr>
<tr>
<td>2.2.x Froyo</td>
<td>2.6.32</td>
</tr>
<tr>
<td>2.3.x Gingerbread</td>
<td>2.6.35</td>
</tr>
<tr>
<td>3.x.x Honeycomb</td>
<td>2.6.36</td>
</tr>
<tr>
<td>4.0.x Ice Cream San</td>
<td>3.0.1</td>
</tr>
</tbody></table>
</li>
<li><p>你在你的主机上面安装了一张网卡，但是开机之后，系统却无法使用，你确定网卡是好的，那么可能的问题出在哪里？该如何解决？</p>
<p><em>因为硬件都没有问题，所以，可能出问题的地方在于系统的核心不支持这种网卡。解决方法是：（1）到网卡的开发商网站 （2）下载支持你主机OS的驱动程序 （3）安装网卡的驱动程序后，就可以正常使用了</em></p>
</li>
<li><p>我在Windows上面玩的游戏，可不可以拿到Linux去玩？</p>
<p><em>不行，因为Windows上的应用程序是根据Windows的核心所开发的，同一个应用程序不能在两个不同的操作系统上工作，除非该软件已经进行了移植。</em></p>
</li>
<li><p>Linux本身仅是一个核心与相关的核心工具而已，不过，他已经可以驱动所有的硬件，所 以，可以算是一个很阳春的操作系统了。经过其他应用程序的开发之后，被整合成为 Linux distribitions。请问众多的distributions之间，有何异同？</p>
<p><em>相同：（1）同样使用<a href="http://www.kernel.org" target="_blank" rel="noopener">http://www.kernel.org</a>所释出的核心； （2）支持同意的标准，如FHS，LSB （3）使用几乎相同的自由软件 （4）几乎相同的操作接口</em></p>
<p><em>不同：使用的Kernel与各软件的版本可能不同；各开发商加入的应用工具不同，使用的套件管理模式不同</em></p>
</li>
<li><p>GNU的全名为何？他主要由那个基金会支持？</p>
<p><em>GNU的全名是GNU is not Unix，该计划是由自由软件基金会（FSF）所支持的。这两者都是由Stallman所发起的</em></p>
</li>
<li><p>什么是POSIX?为何说Linux使用POSIX对于发展有很好的影响？</p>
<p><em>POSIX是一种标准规范，主要针对在Unix上面运行的程序进行规范。若OS符合POSIX，则符合POSIX的程序就可以在该OS上运行。Linux由于支持POSIX，故很多的Unix上的程序可以直接在Linux上运行，因此程序的移植相对简单。</em></p>
</li>
</ol>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>阿飞学Linux——（2）主机规划与磁盘分区</title>
    <url>/2020/06/27/%E9%98%BF%E9%A3%9E%E5%AD%A6Linux%E2%80%94%E2%80%94%EF%BC%882%EF%BC%89%E4%B8%BB%E6%9C%BA%E8%A7%84%E5%88%92%E4%B8%8E%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA/</url>
    <content><![CDATA[<h1 id="Linux与硬件的搭配"><a href="#Linux与硬件的搭配" class="headerlink" title="Linux与硬件的搭配"></a>Linux与硬件的搭配</h1><p>在安装Linux之前，应该先了解下你的Linux主要是想完成哪方面的工作，这样在选购硬件的时候才能知道哪个硬件是最重要的。</p>
<h2 id="选择与Linux搭配的主机配置"><a href="#选择与Linux搭配的主机配置" class="headerlink" title="选择与Linux搭配的主机配置"></a>选择与Linux搭配的主机配置</h2><ul>
<li><p>一般小型主机且不含X Window系统：</p>
<ul>
<li><p>用途：家庭用NAT主机（IP分享器功能）或小型企业之非图形接口小型主机</p>
</li>
<li><p>CPU：五年内出产的产品即可</p>
</li>
<li><p>RAM：521MB~1GB</p>
</li>
<li><p>网卡：一般的以太网卡即可</p>
</li>
<li><p>显卡：只要能够被Linux捕捉到的显卡即可</p>
</li>
<li><p>硬盘：20GB以上即可</p>
<a id="more"></a>
</li>
</ul>
</li>
<li><p>桌上型Linux系统/含X Window：</p>
<ul>
<li>用途：Linux的练习机或工作机</li>
<li>CPU：最好等级高点，如Intel i5，i7以上等级</li>
<li>RAM：大于1GB</li>
<li>网卡：普通的以太网卡即可</li>
<li>显卡：入门级显卡即可</li>
<li>硬盘：越大越好</li>
</ul>
</li>
<li><p>中型以上Linux服务器：</p>
<ul>
<li>用途：中小型企业/学校单位的FTP/mail/www等网络服务主机</li>
<li>CPU：最好等级高点，如Intel i5，i7以上的多核心系统</li>
<li>RAM：大于1GB</li>
<li>网卡：intel或broadcom的品牌较好</li>
<li>显卡：入门级显卡即可</li>
<li>硬盘：越大越好，可能的话使用磁盘阵列</li>
</ul>
</li>
</ul>
<h2 id="各硬件设备在Linux中的文件名"><a href="#各硬件设备在Linux中的文件名" class="headerlink" title="各硬件设备在Linux中的文件名"></a>各硬件设备在Linux中的文件名</h2><p><strong>在Linux中，每个设备都被当成一个文件来对待</strong>，在Linux中，几乎所有的硬件设备文件都在<strong>/dev</strong>这个目录下。常见的硬件设备在Linux中的文件名如下表所示：</p>
<table>
<thead>
<tr>
<th>设备</th>
<th>设备在Linux内的文件名</th>
</tr>
</thead>
<tbody><tr>
<td>SAS/SATA/USB硬盘</td>
<td>/dev/sd[a-p]</td>
</tr>
<tr>
<td>U盘</td>
<td>/dev/sd[a-p] （与SATA相同）</td>
</tr>
<tr>
<td>VirtI/O接口</td>
<td>/dev/vd[a-p] （用于虚拟机内）</td>
</tr>
<tr>
<td>软盘</td>
<td>/dev/fd[0-7]</td>
</tr>
<tr>
<td>打印机</td>
<td>/dev/lp[0-2] （25针打印机）            /dev/usb/lp[0-15] （USB接口）</td>
</tr>
<tr>
<td>鼠标</td>
<td>/dev/input/mouse[0-15] （通用）           /dev/mouse （当前鼠标）</td>
</tr>
<tr>
<td>CDROM/DVDROM</td>
<td>/dev/scd[0-1] （通用）      /dev/cdrom （当前CDROM)）     /dev/sr[0-1]（通用，Centos较常见）</td>
</tr>
<tr>
<td>IDE硬盘</td>
<td>/dev/hd[a-d]（旧式系统才有）</td>
</tr>
</tbody></table>
<h1 id="磁盘分区"><a href="#磁盘分区" class="headerlink" title="磁盘分区"></a>磁盘分区</h1><h2 id="磁盘连接的方式与设备文件名的关系"><a href="#磁盘连接的方式与设备文件名的关系" class="headerlink" title="磁盘连接的方式与设备文件名的关系"></a>磁盘连接的方式与设备文件名的关系</h2><p>目前主流的磁盘接口是SATA接口，如今大部分的Linux distribution已经将ide接口的磁盘文件名也仿真成了SATA接口了。</p>
<p>正常的实体机器上的磁盘文件名大概都是/dev/sd[a-p]，而在虚拟机环境下，磁盘文件名大概就是/dev/vd[a-p]。</p>
<p>如果一个计算机系统内有多个SATA/USB/SAS接口的磁盘，由于他们的设备文件名都是/dev/sd[a-p]，故这些磁盘的设备文件名取决于Linux核心侦测到磁盘的顺序。</p>
<h2 id="MBR和GPT磁盘分区表"><a href="#MBR和GPT磁盘分区表" class="headerlink" title="MBR和GPT磁盘分区表"></a>MBR和GPT磁盘分区表</h2><p>磁盘的第一个扇区记录整颗磁盘的重要信息。早期磁盘第一个扇区里含有的重要信息我们称之为MBR格式。如今随着需求的变化，我们称这些重要信息为GPT。</p>
<ul>
<li><p>MBR</p>
<p>早期的Linux为了相同于Windows的磁盘，因此使用的是支持Windows的MBR的方式来处理开机管理程序和分区表。故磁盘的第一个扇区（512 Byte）存放了两个重要数据</p>
<ul>
<li>主要开机记录区（MBR）：可以安装开机管理程序的地方，有446 Bytes</li>
<li>分区表：记录整颗磁盘分区的状态，有64 Bytes</li>
</ul>
<p>由于分区表只有64 Bytes，故最多只能写入4组分区信息，每组分区信息记录了该分区的开始与结束的柱面号码，这四组分区称之为<strong>主要或延伸分区</strong>，分区的最小单位为通常为柱面。当系统要写入磁盘时，一定会参考磁盘分区表，才能针对某个分区进行数据的处理。</p>
<p>如果我们要将磁盘划分出4个以上的分区，就要借助于延伸分区。<strong>延伸分区的思想是：既然第一个扇区所在的分区表只能记录4组分区信息，那就利用额外的扇区来记录更多的分区信息。</strong>延伸分区本身不能被格式化，而是通过延伸分区所指向的那个区块继续做分区的记录。<strong>延伸分区最多只能有一个。</strong></p>
<img src="http://linux.vbird.org/linux_basic/0130designlinux/partition-2.png" alt="磁盘分区表的作用" style="zoom: 80%;" />

<p>如上图所示，右下方的那个区块又继续分区出5个分区，这5个分区称为<strong>逻辑分区</strong>。逻辑分区的柱面范围就是延伸分区所设置的范围。上图分区的设备文件名如下：</p>
<ul>
<li>p1:/dev/sda1</li>
<li>p2:/dev/sda2</li>
<li>L1:/dev/sda5</li>
<li>L2:/dev/sda6</li>
<li>L3:/dev/sda7</li>
<li>L4:/dev/sda8</li>
<li>L5:/dev/sda9</li>
</ul>
<p><strong>注意：前4个分区号码是保留给主要和延伸分区的。</strong></p>
</li>
<li><p>GPT</p>
<p>为了解决MBR分区表无法记录2.2T以上的磁盘的问题，引入了GPT分区表。</p>
<img src="http://linux.vbird.org/linux_basic/0130designlinux/gpt_partition_1.jpg" alt="GPT分区表结构" style="zoom:80%;" />

<p>GPT使用了34个LBA[^1]区块来记录分区信息，并且利用磁盘的最后33个LBA作为分区信息的备份。</p>
<ul>
<li><p>LBA0（MBR相容区块）</p>
<p>该分区放入一个特殊标记，用来表示该磁盘为GPT格式，如果不懂GPT分区表的磁盘管理程序，就不会认识该磁盘。进一步保护了该磁盘。</p>
</li>
<li><p>LBA1（GPT表头记录）</p>
<p>记录了分区表的位置与大小，同时记录了备份用的GPT分区表所放置的位置，同时放置了分区表的校验机制码。</p>
</li>
<li><p>LBA2-33（实际记录分区信息处）</p>
<p>从LBA2区块开始，每个LBA记录了4笔分区记录，故在默认情况下，可以有4*32 = 128笔分区记录。由于每个LBA有512 Bytes，故每笔记录用到了128 Bytes的空间。</p>
</li>
</ul>
<p>不同于MBR，GPT中没有延伸，主要，逻辑分区的概念，每个分区都是独立的，都可以进行格式化。</p>
</li>
</ul>
<h2 id="开机检测程序：BIOS与UEFI"><a href="#开机检测程序：BIOS与UEFI" class="headerlink" title="开机检测程序：BIOS与UEFI"></a>开机检测程序：BIOS与UEFI</h2><ul>
<li><p>BIOS搭配MBR/GPT的开机流程</p>
<ol>
<li>BIOS：开机的时候主动执行BIOS，根据使用者的设定取得能够开机的硬盘</li>
<li>MBR：BIOS读取第一个可开机设备的第一个扇区的开机记录区块，执行开机管理程序</li>
<li>开机管理程序：载入核心文件</li>
<li>核心文件：开始OS的功能</li>
</ol>
<p>对于第2点，如果分区表为GPT格式的话，那么BIOS会从LBA0的MBR相容区块读取第一阶段的开机管理程序，如果开机管理程序能够认识GPT的话，那么使用BIOS同样可以读取到正确的OS核心。</p>
<p><strong>开机管理程序除了可以安装在MBR之外，还可以安装在每个分区的开机扇区，通过特色才能造就“多重开机“。开机管理程序的功能是：提供菜单；载入核心文件；转交其他的loader。</strong></p>
</li>
<li><p>UEFI搭配GPT开机的流程</p>
<p>BIOS不懂GPT，必须要通过GPT提供的MBR相容区块才能够读写该磁盘设备。因此，对比BIOS，UEFI虽然可以直接取得GPT的分区表，不过最好依旧拥有BIOS boot的分区支持。</p>
</li>
</ul>
<h2 id="Linux安装模式下，磁盘分区的选择"><a href="#Linux安装模式下，磁盘分区的选择" class="headerlink" title="Linux安装模式下，磁盘分区的选择"></a>Linux安装模式下，磁盘分区的选择</h2><ul>
<li><p>目录树结构</p>
<p>所谓的目录树结构就是以根目录/为主，然后向下呈现分枝状的目录结构的一种文件架构。</p>
<p><img src="http://linux.vbird.org/linux_basic/0130designlinux/dirtree.gif" alt="目录树结构"></p>
<p>上图中，长方形为目录，波浪形为文件。可见，所有的文件都是由根目录（/）发起，而次目录下还能够有其他的数据存在。</p>
</li>
<li><p>文件系统与目录树的关系（挂载）</p>
<p>所谓的”挂载“就是利用一个目录当成进入点，将磁盘分区的数据放置在该目录下。简单来说，就是进入该目录就可以读取该分区的意思。这个进入点的目录称之为<strong>”挂载点“</strong>。</p>
<img src="http://linux.vbird.org/linux_basic/0130designlinux/dir_3.png" alt="目录树与分区间的关系" style="zoom:80%;" />

</li>
</ul>
<h1 id="主机硬盘的规划"><a href="#主机硬盘的规划" class="headerlink" title="主机硬盘的规划"></a>主机硬盘的规划</h1><ul>
<li>最简单的分区方法：仅分区出根目录（/）与内存交换空间（swap）即可。然后，预留一些剩余的磁盘供后续的联系使用。</li>
<li>较麻烦的分区方法：先分析该主机的未来用途，然后根据用途去分析需要较大容量的目录，以及读写较为频繁的目录，将这些重要的目录独立出来而不与根目录（/）放在一起。使得当这些读写较为频繁的磁盘分区出现问题时，不会影响到根目录的系统数据。在默认的Centos环境中，下面的目录是比较符合容量大且读写频繁的目录：<ul>
<li>/boot</li>
<li>/</li>
<li>/home</li>
<li>/var</li>
<li>Swap</li>
</ul>
</li>
</ul>
<h1 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h1><ol>
<li><p>一部计算机主机是否只要CPU够快，整体速度就会提高？</p>
<p><em>错！一部计算机系统的速度与整体计算机系统的运行有关，每个元件都会影响计算机的速度。包括了内存，CPU，AGP与显卡速度，硬盘的速度以及其他相关的I/O接口等。</em></p>
</li>
<li><p>一部好的主机在安装之前，最好先进行规划，哪些是必须要主要的Linux主机规划事项？</p>
<p><em>Linux主机在安装之前，一定要规划Linux主机的定位与角色！因此，Linux的主机是否开放网络服务？未来是否会进行大量的运算？该主机是否需要提供很大的硬盘容量来服务客户端的使用？这些都是要经过考虑的。</em></p>
</li>
<li><p>请写出下列设备，在Linux的设备文件名：SATA硬盘；CDROM；打印机；软盘；</p>
<p><em>SATA硬盘：/dev/sd[a-p]</em></p>
<p><em>CDROM：/dev/cdrom，/dev/sr[0-1]，/dev/scd[0-1]</em></p>
<p><em>打印机：/dev/lp[0-2]</em></p>
<p><em>软盘：/dev/fd[0-1]</em></p>
</li>
<li><p>目前在PC上面常见的硬盘与主板的连接接口有那两个？</p>
<p><em>有内置的SATA接口与外接式的USB接口</em></p>
</li>
</ol>
<p>[^1]: 逻辑区块地址，GPT将磁盘所有区块以LBA（默认为512 Bytes）来规划，第一个LBA称为LBA0</p>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>阿飞学Linux——（3）安装Centos7.x</title>
    <url>/2020/06/29/%E9%98%BF%E9%A3%9E%E5%AD%A6Linux%E2%80%94%E2%80%94%EF%BC%883%EF%BC%89%E5%AE%89%E8%A3%85Centos7-x/</url>
    <content><![CDATA[<h1 id="本练习机的规划"><a href="#本练习机的规划" class="headerlink" title="本练习机的规划"></a>本练习机的规划</h1><ol>
<li>Linux主机的角色定位</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>阿飞学Markdown</title>
    <url>/2020/06/13/%E9%98%BF%E9%A3%9E%E5%AD%A6Markdown/</url>
    <content><![CDATA[<h1 id="Markdown是什么"><a href="#Markdown是什么" class="headerlink" title="Markdown是什么"></a>Markdown是什么</h1><p>Markdown就是由一些简单的符号（如***** /-&gt; [] （）#）组成的用于排版的标记语言，其最重要的特点就是可读性强。</p>
<p>Markdown的语法分为，基础语法和扩展语法。在众多的扩展语法中GFM是最流行的，它扩展了包括表格，任务列表，删除线，围栏代码，Emoji等在内的语法。</p>
<a id="more"></a>

<h2 id="Markdown的工作流程"><a href="#Markdown的工作流程" class="headerlink" title="Markdown的工作流程"></a>Markdown的工作流程</h2><p><img src="/images/Image00007.jpg" alt="Markdown工作流程"></p>
<h2 id="Markdown的编辑器"><a href="#Markdown的编辑器" class="headerlink" title="Markdown的编辑器"></a>Markdown的编辑器</h2><p>这里推荐两个流行的Markdown编辑器，分别是Typora和vs Code.下载地址如下:</p>
<p>typora:  <a href="https://typora.io/" target="_blank" rel="noopener">https://typora.io/</a></p>
<p>vs Code: <a href="https://code.visualstudio.com/download" target="_blank" rel="noopener">https://code.visualstudio.com/download</a></p>
<h1 id="Markdown的基础语法"><a href="#Markdown的基础语法" class="headerlink" title="Markdown的基础语法"></a>Markdown的基础语法</h1><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><ol>
<li>标题<ul>
<li>语法：<code># + 空格 + 标题内容</code></li>
<li>说明：#的个数表示了标题的等级，建议在#后加一个空格</li>
</ul>
</li>
<li>粗体<ul>
<li>语法：<code>**+加粗内容+**</code></li>
<li>说明：在*的后面不带有空格</li>
</ul>
</li>
<li>斜体<ul>
<li>语法：<code>*+斜体内容+*</code></li>
<li>说明：在*的后面不带有空格</li>
</ul>
</li>
</ol>
<h2 id="段落与换行"><a href="#段落与换行" class="headerlink" title="段落与换行"></a>段落与换行</h2><ol>
<li><p>列表</p>
<ul>
<li>有序列表<ul>
<li>语法：<code>数字序号 + . + 空格 + 列表内容</code></li>
</ul>
</li>
<li>无须列表<ul>
<li>语法：<code>* + 空格 + 列表内容</code></li>
</ul>
</li>
<li>说明：列表可相互嵌套，有序列表和无序列表之间也可以相互嵌套。（<em>建议在列表前/后都空1行</em>）</li>
</ul>
</li>
<li><p>分割线</p>
<ul>
<li>语法：<code>---</code></li>
<li>说明：至少要有三个以上的 - 来标记</li>
</ul>
</li>
<li><p>图片</p>
<ul>
<li>语法：<code>![图片替代文字](图片地址)</code></li>
<li>说明：图片地址可以是本地图片(<a href="[http://www.theoak.online/2020/03/13/hexo%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%E4%B8%8D%E6%98%BE%E7%A4%BA/](http://www.theoak.online/2020/03/13/hexo本地图片不显示/)">关于hexo引用本地图片无法显示</a>)的路径或是网络图片的地址；支持绝对路径和相对路径两种方式.</li>
</ul>
</li>
<li><p>链接</p>
<ul>
<li><p>文字链接</p>
<ul>
<li>语法：<code>[链接文字]（链接地址）</code></li>
<li>说明：在扩展语法GFM中，可以只输入url，也能被自动识别为网络链接</li>
</ul>
</li>
<li><p>引用链接</p>
<ul>
<li><p>语法：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">链接文字</span>][<span class="symbol">链接标记</span>]</span><br><span class="line">[<span class="symbol">链接标记</span>]:<span class="link">链接地址</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>说明：链接地址为网络地址时要以http开头，否则会被识别为本地地址</p>
</li>
</ul>
</li>
<li><p>网址链接</p>
<ul>
<li>语法：<code>&lt;url&gt;</code></li>
</ul>
</li>
</ul>
</li>
<li><p>代码块</p>
<ul>
<li><p>行内代码</p>
</li>
<li><p>语法：&#39;代码&#39;</p>
</li>
<li><p>代码块</p>
<ul>
<li><p>语法：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">···语言</span><br><span class="line">代码</span><br><span class="line">···</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>引用</p>
<ul>
<li>语法：<code>&gt;+应用内容</code></li>
<li>说明：引用可以嵌套；建议在&gt;之后加一个空格；不要在引用中添加空行</li>
</ul>
</li>
</ol>
<h1 id="Markdown的扩展语法"><a href="#Markdown的扩展语法" class="headerlink" title="Markdown的扩展语法"></a>Markdown的扩展语法</h1><ol>
<li><p>删除线</p>
<ul>
<li>语法：<code>~~被删除的文字~~</code></li>
</ul>
</li>
<li><p>Emoji表情</p>
<ul>
<li>语法：<code>:表情代码:</code></li>
</ul>
</li>
<li><p>表格</p>
<ul>
<li><p>语法：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">|表头1|表头2|表头3|</span><br><span class="line">|----|----|----|</span><br><span class="line">|内容1|内容2|内容3|</span><br></pre></td></tr></table></figure>
</li>
<li><p>说明：块级元素不能插入表格中</p>
</li>
</ul>
</li>
<li><p>任务列表</p>
<ul>
<li>语法：<code>- + 空格 + [ + 空格/x + ] 任务内容</code></li>
</ul>
</li>
<li><p>锚点（书签）</p>
<ul>
<li>语法：<code>[锚点描述](#锚点名)</code> </li>
</ul>
</li>
<li><p>上标和下标</p>
<ul>
<li>语法：<code>~下标内容~</code>      <code>^上标内容^</code></li>
</ul>
</li>
<li><p>注释</p>
<ul>
<li>语法：<code>&lt;!--注释内容--&gt;</code></li>
</ul>
</li>
<li><p>脚注</p>
<ul>
<li><p>语法：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">欲添加脚注的内容[^脚注]</span><br><span class="line">[<span class="symbol">^脚注</span>]:<span class="link">这段文字是对脚注的描述</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
</search>
